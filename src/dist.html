<!DOCTYPE html>
<html lang="en">

<head>
  <title>Crash trigger</title>
  <script>
    /*! For license information please see main.js.LICENSE.txt */
    (() => { var e = { 742: (e, t) => { "use strict"; t.byteLength = function (e) { var t = l(e), r = t[0], n = t[1]; return 3 * (r + n) / 4 - n }, t.toByteArray = function (e) { var t, r, i = l(e), s = i[0], a = i[1], u = new o(function (e, t, r) { return 3 * (t + r) / 4 - r }(0, s, a)), c = 0, d = a > 0 ? s - 4 : s; for (r = 0; r < d; r += 4)t = n[e.charCodeAt(r)] << 18 | n[e.charCodeAt(r + 1)] << 12 | n[e.charCodeAt(r + 2)] << 6 | n[e.charCodeAt(r + 3)], u[c++] = t >> 16 & 255, u[c++] = t >> 8 & 255, u[c++] = 255 & t; return 2 === a && (t = n[e.charCodeAt(r)] << 2 | n[e.charCodeAt(r + 1)] >> 4, u[c++] = 255 & t), 1 === a && (t = n[e.charCodeAt(r)] << 10 | n[e.charCodeAt(r + 1)] << 4 | n[e.charCodeAt(r + 2)] >> 2, u[c++] = t >> 8 & 255, u[c++] = 255 & t), u }, t.fromByteArray = function (e) { for (var t, n = e.length, o = n % 3, i = [], s = 16383, a = 0, l = n - o; a < l; a += s)i.push(u(e, a, a + s > l ? l : a + s)); return 1 === o ? (t = e[n - 1], i.push(r[t >> 2] + r[t << 4 & 63] + "==")) : 2 === o && (t = (e[n - 2] << 8) + e[n - 1], i.push(r[t >> 10] + r[t >> 4 & 63] + r[t << 2 & 63] + "=")), i.join("") }; for (var r = [], n = [], o = "undefined" != typeof Uint8Array ? Uint8Array : Array, i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0, a = i.length; s < a; ++s)r[s] = i[s], n[i.charCodeAt(s)] = s; function l(e) { var t = e.length; if (t % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4"); var r = e.indexOf("="); return -1 === r && (r = t), [r, r === t ? 0 : 4 - r % 4] } function u(e, t, n) { for (var o, i, s = [], a = t; a < n; a += 3)o = (e[a] << 16 & 16711680) + (e[a + 1] << 8 & 65280) + (255 & e[a + 2]), s.push(r[(i = o) >> 18 & 63] + r[i >> 12 & 63] + r[i >> 6 & 63] + r[63 & i]); return s.join("") } n["-".charCodeAt(0)] = 62, n["_".charCodeAt(0)] = 63 }, 764: (e, t, r) => { "use strict"; const n = r(742), o = r(645), i = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null; t.Buffer = l, t.SlowBuffer = function (e) { return +e != e && (e = 0), l.alloc(+e) }, t.INSPECT_MAX_BYTES = 50; const s = 2147483647; function a(e) { if (e > s) throw new RangeError('The value "' + e + '" is invalid for option "size"'); const t = new Uint8Array(e); return Object.setPrototypeOf(t, l.prototype), t } function l(e, t, r) { if ("number" == typeof e) { if ("string" == typeof t) throw new TypeError('The "string" argument must be of type string. Received type number'); return d(e) } return u(e, t, r) } function u(e, t, r) { if ("string" == typeof e) return function (e, t) { if ("string" == typeof t && "" !== t || (t = "utf8"), !l.isEncoding(t)) throw new TypeError("Unknown encoding: " + t); const r = 0 | b(e, t); let n = a(r); const o = n.write(e, t); return o !== r && (n = n.slice(0, o)), n }(e, t); if (ArrayBuffer.isView(e)) return function (e) { if (Q(e, Uint8Array)) { const t = new Uint8Array(e); return f(t.buffer, t.byteOffset, t.byteLength) } return h(e) }(e); if (null == e) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e); if (Q(e, ArrayBuffer) || e && Q(e.buffer, ArrayBuffer)) return f(e, t, r); if ("undefined" != typeof SharedArrayBuffer && (Q(e, SharedArrayBuffer) || e && Q(e.buffer, SharedArrayBuffer))) return f(e, t, r); if ("number" == typeof e) throw new TypeError('The "value" argument must not be of type number. Received type number'); const n = e.valueOf && e.valueOf(); if (null != n && n !== e) return l.from(n, t, r); const o = function (e) { if (l.isBuffer(e)) { const t = 0 | p(e.length), r = a(t); return 0 === r.length || e.copy(r, 0, 0, t), r } return void 0 !== e.length ? "number" != typeof e.length || G(e.length) ? a(0) : h(e) : "Buffer" === e.type && Array.isArray(e.data) ? h(e.data) : void 0 }(e); if (o) return o; if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e[Symbol.toPrimitive]) return l.from(e[Symbol.toPrimitive]("string"), t, r); throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e) } function c(e) { if ("number" != typeof e) throw new TypeError('"size" argument must be of type number'); if (e < 0) throw new RangeError('The value "' + e + '" is invalid for option "size"') } function d(e) { return c(e), a(e < 0 ? 0 : 0 | p(e)) } function h(e) { const t = e.length < 0 ? 0 : 0 | p(e.length), r = a(t); for (let n = 0; n < t; n += 1)r[n] = 255 & e[n]; return r } function f(e, t, r) { if (t < 0 || e.byteLength < t) throw new RangeError('"offset" is outside of buffer bounds'); if (e.byteLength < t + (r || 0)) throw new RangeError('"length" is outside of buffer bounds'); let n; return n = void 0 === t && void 0 === r ? new Uint8Array(e) : void 0 === r ? new Uint8Array(e, t) : new Uint8Array(e, t, r), Object.setPrototypeOf(n, l.prototype), n } function p(e) { if (e >= s) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s.toString(16) + " bytes"); return 0 | e } function b(e, t) { if (l.isBuffer(e)) return e.length; if (ArrayBuffer.isView(e) || Q(e, ArrayBuffer)) return e.byteLength; if ("string" != typeof e) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e); const r = e.length, n = arguments.length > 2 && !0 === arguments[2]; if (!n && 0 === r) return 0; let o = !1; for (; ;)switch (t) { case "ascii": case "latin1": case "binary": return r; case "utf8": case "utf-8": return H(e).length; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return 2 * r; case "hex": return r >>> 1; case "base64": return K(e).length; default: if (o) return n ? -1 : H(e).length; t = ("" + t).toLowerCase(), o = !0 } } function y(e, t, r) { let n = !1; if ((void 0 === t || t < 0) && (t = 0), t > this.length) return ""; if ((void 0 === r || r > this.length) && (r = this.length), r <= 0) return ""; if ((r >>>= 0) <= (t >>>= 0)) return ""; for (e || (e = "utf8"); ;)switch (e) { case "hex": return P(this, t, r); case "utf8": case "utf-8": return k(this, t, r); case "ascii": return I(this, t, r); case "latin1": case "binary": return O(this, t, r); case "base64": return T(this, t, r); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return B(this, t, r); default: if (n) throw new TypeError("Unknown encoding: " + e); e = (e + "").toLowerCase(), n = !0 } } function g(e, t, r) { const n = e[t]; e[t] = e[r], e[r] = n } function w(e, t, r, n, o) { if (0 === e.length) return -1; if ("string" == typeof r ? (n = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), G(r = +r) && (r = o ? 0 : e.length - 1), r < 0 && (r = e.length + r), r >= e.length) { if (o) return -1; r = e.length - 1 } else if (r < 0) { if (!o) return -1; r = 0 } if ("string" == typeof t && (t = l.from(t, n)), l.isBuffer(t)) return 0 === t.length ? -1 : _(e, t, r, n, o); if ("number" == typeof t) return t &= 255, "function" == typeof Uint8Array.prototype.indexOf ? o ? Uint8Array.prototype.indexOf.call(e, t, r) : Uint8Array.prototype.lastIndexOf.call(e, t, r) : _(e, [t], r, n, o); throw new TypeError("val must be string, number or Buffer") } function _(e, t, r, n, o) { let i, s = 1, a = e.length, l = t.length; if (void 0 !== n && ("ucs2" === (n = String(n).toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) { if (e.length < 2 || t.length < 2) return -1; s = 2, a /= 2, l /= 2, r /= 2 } function u(e, t) { return 1 === s ? e[t] : e.readUInt16BE(t * s) } if (o) { let n = -1; for (i = r; i < a; i++)if (u(e, i) === u(t, -1 === n ? 0 : i - n)) { if (-1 === n && (n = i), i - n + 1 === l) return n * s } else -1 !== n && (i -= i - n), n = -1 } else for (r + l > a && (r = a - l), i = r; i >= 0; i--) { let r = !0; for (let n = 0; n < l; n++)if (u(e, i + n) !== u(t, n)) { r = !1; break } if (r) return i } return -1 } function m(e, t, r, n) { r = Number(r) || 0; const o = e.length - r; n ? (n = Number(n)) > o && (n = o) : n = o; const i = t.length; let s; for (n > i / 2 && (n = i / 2), s = 0; s < n; ++s) { const n = parseInt(t.substr(2 * s, 2), 16); if (G(n)) return s; e[r + s] = n } return s } function v(e, t, r, n) { return Y(H(t, e.length - r), e, r, n) } function S(e, t, r, n) { return Y(function (e) { const t = []; for (let r = 0; r < e.length; ++r)t.push(255 & e.charCodeAt(r)); return t }(t), e, r, n) } function E(e, t, r, n) { return Y(K(t), e, r, n) } function R(e, t, r, n) { return Y(function (e, t) { let r, n, o; const i = []; for (let s = 0; s < e.length && !((t -= 2) < 0); ++s)r = e.charCodeAt(s), n = r >> 8, o = r % 256, i.push(o), i.push(n); return i }(t, e.length - r), e, r, n) } function T(e, t, r) { return 0 === t && r === e.length ? n.fromByteArray(e) : n.fromByteArray(e.slice(t, r)) } function k(e, t, r) { r = Math.min(e.length, r); const n = []; let o = t; for (; o < r;) { const t = e[o]; let i = null, s = t > 239 ? 4 : t > 223 ? 3 : t > 191 ? 2 : 1; if (o + s <= r) { let r, n, a, l; switch (s) { case 1: t < 128 && (i = t); break; case 2: r = e[o + 1], 128 == (192 & r) && (l = (31 & t) << 6 | 63 & r, l > 127 && (i = l)); break; case 3: r = e[o + 1], n = e[o + 2], 128 == (192 & r) && 128 == (192 & n) && (l = (15 & t) << 12 | (63 & r) << 6 | 63 & n, l > 2047 && (l < 55296 || l > 57343) && (i = l)); break; case 4: r = e[o + 1], n = e[o + 2], a = e[o + 3], 128 == (192 & r) && 128 == (192 & n) && 128 == (192 & a) && (l = (15 & t) << 18 | (63 & r) << 12 | (63 & n) << 6 | 63 & a, l > 65535 && l < 1114112 && (i = l)) } } null === i ? (i = 65533, s = 1) : i > 65535 && (i -= 65536, n.push(i >>> 10 & 1023 | 55296), i = 56320 | 1023 & i), n.push(i), o += s } return function (e) { const t = e.length; if (t <= A) return String.fromCharCode.apply(String, e); let r = "", n = 0; for (; n < t;)r += String.fromCharCode.apply(String, e.slice(n, n += A)); return r }(n) } t.kMaxLength = s, l.TYPED_ARRAY_SUPPORT = function () { try { const e = new Uint8Array(1), t = { foo: function () { return 42 } }; return Object.setPrototypeOf(t, Uint8Array.prototype), Object.setPrototypeOf(e, t), 42 === e.foo() } catch (e) { return !1 } }(), l.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(l.prototype, "parent", { enumerable: !0, get: function () { if (l.isBuffer(this)) return this.buffer } }), Object.defineProperty(l.prototype, "offset", { enumerable: !0, get: function () { if (l.isBuffer(this)) return this.byteOffset } }), l.poolSize = 8192, l.from = function (e, t, r) { return u(e, t, r) }, Object.setPrototypeOf(l.prototype, Uint8Array.prototype), Object.setPrototypeOf(l, Uint8Array), l.alloc = function (e, t, r) { return function (e, t, r) { return c(e), e <= 0 ? a(e) : void 0 !== t ? "string" == typeof r ? a(e).fill(t, r) : a(e).fill(t) : a(e) }(e, t, r) }, l.allocUnsafe = function (e) { return d(e) }, l.allocUnsafeSlow = function (e) { return d(e) }, l.isBuffer = function (e) { return null != e && !0 === e._isBuffer && e !== l.prototype }, l.compare = function (e, t) { if (Q(e, Uint8Array) && (e = l.from(e, e.offset, e.byteLength)), Q(t, Uint8Array) && (t = l.from(t, t.offset, t.byteLength)), !l.isBuffer(e) || !l.isBuffer(t)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'); if (e === t) return 0; let r = e.length, n = t.length; for (let o = 0, i = Math.min(r, n); o < i; ++o)if (e[o] !== t[o]) { r = e[o], n = t[o]; break } return r < n ? -1 : n < r ? 1 : 0 }, l.isEncoding = function (e) { switch (String(e).toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "latin1": case "binary": case "base64": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return !0; default: return !1 } }, l.concat = function (e, t) { if (!Array.isArray(e)) throw new TypeError('"list" argument must be an Array of Buffers'); if (0 === e.length) return l.alloc(0); let r; if (void 0 === t) for (t = 0, r = 0; r < e.length; ++r)t += e[r].length; const n = l.allocUnsafe(t); let o = 0; for (r = 0; r < e.length; ++r) { let t = e[r]; if (Q(t, Uint8Array)) o + t.length > n.length ? (l.isBuffer(t) || (t = l.from(t)), t.copy(n, o)) : Uint8Array.prototype.set.call(n, t, o); else { if (!l.isBuffer(t)) throw new TypeError('"list" argument must be an Array of Buffers'); t.copy(n, o) } o += t.length } return n }, l.byteLength = b, l.prototype._isBuffer = !0, l.prototype.swap16 = function () { const e = this.length; if (e % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits"); for (let t = 0; t < e; t += 2)g(this, t, t + 1); return this }, l.prototype.swap32 = function () { const e = this.length; if (e % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits"); for (let t = 0; t < e; t += 4)g(this, t, t + 3), g(this, t + 1, t + 2); return this }, l.prototype.swap64 = function () { const e = this.length; if (e % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits"); for (let t = 0; t < e; t += 8)g(this, t, t + 7), g(this, t + 1, t + 6), g(this, t + 2, t + 5), g(this, t + 3, t + 4); return this }, l.prototype.toString = function () { const e = this.length; return 0 === e ? "" : 0 === arguments.length ? k(this, 0, e) : y.apply(this, arguments) }, l.prototype.toLocaleString = l.prototype.toString, l.prototype.equals = function (e) { if (!l.isBuffer(e)) throw new TypeError("Argument must be a Buffer"); return this === e || 0 === l.compare(this, e) }, l.prototype.inspect = function () { let e = ""; const r = t.INSPECT_MAX_BYTES; return e = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (e += " ... "), "<Buffer " + e + ">" }, i && (l.prototype[i] = l.prototype.inspect), l.prototype.compare = function (e, t, r, n, o) { if (Q(e, Uint8Array) && (e = l.from(e, e.offset, e.byteLength)), !l.isBuffer(e)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e); if (void 0 === t && (t = 0), void 0 === r && (r = e ? e.length : 0), void 0 === n && (n = 0), void 0 === o && (o = this.length), t < 0 || r > e.length || n < 0 || o > this.length) throw new RangeError("out of range index"); if (n >= o && t >= r) return 0; if (n >= o) return -1; if (t >= r) return 1; if (this === e) return 0; let i = (o >>>= 0) - (n >>>= 0), s = (r >>>= 0) - (t >>>= 0); const a = Math.min(i, s), u = this.slice(n, o), c = e.slice(t, r); for (let e = 0; e < a; ++e)if (u[e] !== c[e]) { i = u[e], s = c[e]; break } return i < s ? -1 : s < i ? 1 : 0 }, l.prototype.includes = function (e, t, r) { return -1 !== this.indexOf(e, t, r) }, l.prototype.indexOf = function (e, t, r) { return w(this, e, t, r, !0) }, l.prototype.lastIndexOf = function (e, t, r) { return w(this, e, t, r, !1) }, l.prototype.write = function (e, t, r, n) { if (void 0 === t) n = "utf8", r = this.length, t = 0; else if (void 0 === r && "string" == typeof t) n = t, r = this.length, t = 0; else { if (!isFinite(t)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported"); t >>>= 0, isFinite(r) ? (r >>>= 0, void 0 === n && (n = "utf8")) : (n = r, r = void 0) } const o = this.length - t; if ((void 0 === r || r > o) && (r = o), e.length > 0 && (r < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds"); n || (n = "utf8"); let i = !1; for (; ;)switch (n) { case "hex": return m(this, e, t, r); case "utf8": case "utf-8": return v(this, e, t, r); case "ascii": case "latin1": case "binary": return S(this, e, t, r); case "base64": return E(this, e, t, r); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return R(this, e, t, r); default: if (i) throw new TypeError("Unknown encoding: " + n); n = ("" + n).toLowerCase(), i = !0 } }, l.prototype.toJSON = function () { return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) } }; const A = 4096; function I(e, t, r) { let n = ""; r = Math.min(e.length, r); for (let o = t; o < r; ++o)n += String.fromCharCode(127 & e[o]); return n } function O(e, t, r) { let n = ""; r = Math.min(e.length, r); for (let o = t; o < r; ++o)n += String.fromCharCode(e[o]); return n } function P(e, t, r) { const n = e.length; (!t || t < 0) && (t = 0), (!r || r < 0 || r > n) && (r = n); let o = ""; for (let n = t; n < r; ++n)o += X[e[n]]; return o } function B(e, t, r) { const n = e.slice(t, r); let o = ""; for (let e = 0; e < n.length - 1; e += 2)o += String.fromCharCode(n[e] + 256 * n[e + 1]); return o } function C(e, t, r) { if (e % 1 != 0 || e < 0) throw new RangeError("offset is not uint"); if (e + t > r) throw new RangeError("Trying to access beyond buffer length") } function L(e, t, r, n, o, i) { if (!l.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance'); if (t > o || t < i) throw new RangeError('"value" argument is out of bounds'); if (r + n > e.length) throw new RangeError("Index out of range") } function q(e, t, r, n, o) { $(t, n, o, e, r, 7); let i = Number(t & BigInt(4294967295)); e[r++] = i, i >>= 8, e[r++] = i, i >>= 8, e[r++] = i, i >>= 8, e[r++] = i; let s = Number(t >> BigInt(32) & BigInt(4294967295)); return e[r++] = s, s >>= 8, e[r++] = s, s >>= 8, e[r++] = s, s >>= 8, e[r++] = s, r } function z(e, t, r, n, o) { $(t, n, o, e, r, 7); let i = Number(t & BigInt(4294967295)); e[r + 7] = i, i >>= 8, e[r + 6] = i, i >>= 8, e[r + 5] = i, i >>= 8, e[r + 4] = i; let s = Number(t >> BigInt(32) & BigInt(4294967295)); return e[r + 3] = s, s >>= 8, e[r + 2] = s, s >>= 8, e[r + 1] = s, s >>= 8, e[r] = s, r + 8 } function x(e, t, r, n, o, i) { if (r + n > e.length) throw new RangeError("Index out of range"); if (r < 0) throw new RangeError("Index out of range") } function W(e, t, r, n, i) { return t = +t, r >>>= 0, i || x(e, 0, r, 4), o.write(e, t, r, n, 23, 4), r + 4 } function U(e, t, r, n, i) { return t = +t, r >>>= 0, i || x(e, 0, r, 8), o.write(e, t, r, n, 52, 8), r + 8 } l.prototype.slice = function (e, t) { const r = this.length; (e = ~~e) < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r), (t = void 0 === t ? r : ~~t) < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r), t < e && (t = e); const n = this.subarray(e, t); return Object.setPrototypeOf(n, l.prototype), n }, l.prototype.readUintLE = l.prototype.readUIntLE = function (e, t, r) { e >>>= 0, t >>>= 0, r || C(e, t, this.length); let n = this[e], o = 1, i = 0; for (; ++i < t && (o *= 256);)n += this[e + i] * o; return n }, l.prototype.readUintBE = l.prototype.readUIntBE = function (e, t, r) { e >>>= 0, t >>>= 0, r || C(e, t, this.length); let n = this[e + --t], o = 1; for (; t > 0 && (o *= 256);)n += this[e + --t] * o; return n }, l.prototype.readUint8 = l.prototype.readUInt8 = function (e, t) { return e >>>= 0, t || C(e, 1, this.length), this[e] }, l.prototype.readUint16LE = l.prototype.readUInt16LE = function (e, t) { return e >>>= 0, t || C(e, 2, this.length), this[e] | this[e + 1] << 8 }, l.prototype.readUint16BE = l.prototype.readUInt16BE = function (e, t) { return e >>>= 0, t || C(e, 2, this.length), this[e] << 8 | this[e + 1] }, l.prototype.readUint32LE = l.prototype.readUInt32LE = function (e, t) { return e >>>= 0, t || C(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3] }, l.prototype.readUint32BE = l.prototype.readUInt32BE = function (e, t) { return e >>>= 0, t || C(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]) }, l.prototype.readBigUInt64LE = J((function (e) { M(e >>>= 0, "offset"); const t = this[e], r = this[e + 7]; void 0 !== t && void 0 !== r || D(e, this.length - 8); const n = t + 256 * this[++e] + 65536 * this[++e] + this[++e] * 2 ** 24, o = this[++e] + 256 * this[++e] + 65536 * this[++e] + r * 2 ** 24; return BigInt(n) + (BigInt(o) << BigInt(32)) })), l.prototype.readBigUInt64BE = J((function (e) { M(e >>>= 0, "offset"); const t = this[e], r = this[e + 7]; void 0 !== t && void 0 !== r || D(e, this.length - 8); const n = t * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + this[++e], o = this[++e] * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + r; return (BigInt(n) << BigInt(32)) + BigInt(o) })), l.prototype.readIntLE = function (e, t, r) { e >>>= 0, t >>>= 0, r || C(e, t, this.length); let n = this[e], o = 1, i = 0; for (; ++i < t && (o *= 256);)n += this[e + i] * o; return o *= 128, n >= o && (n -= Math.pow(2, 8 * t)), n }, l.prototype.readIntBE = function (e, t, r) { e >>>= 0, t >>>= 0, r || C(e, t, this.length); let n = t, o = 1, i = this[e + --n]; for (; n > 0 && (o *= 256);)i += this[e + --n] * o; return o *= 128, i >= o && (i -= Math.pow(2, 8 * t)), i }, l.prototype.readInt8 = function (e, t) { return e >>>= 0, t || C(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e] }, l.prototype.readInt16LE = function (e, t) { e >>>= 0, t || C(e, 2, this.length); const r = this[e] | this[e + 1] << 8; return 32768 & r ? 4294901760 | r : r }, l.prototype.readInt16BE = function (e, t) { e >>>= 0, t || C(e, 2, this.length); const r = this[e + 1] | this[e] << 8; return 32768 & r ? 4294901760 | r : r }, l.prototype.readInt32LE = function (e, t) { return e >>>= 0, t || C(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24 }, l.prototype.readInt32BE = function (e, t) { return e >>>= 0, t || C(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3] }, l.prototype.readBigInt64LE = J((function (e) { M(e >>>= 0, "offset"); const t = this[e], r = this[e + 7]; void 0 !== t && void 0 !== r || D(e, this.length - 8); const n = this[e + 4] + 256 * this[e + 5] + 65536 * this[e + 6] + (r << 24); return (BigInt(n) << BigInt(32)) + BigInt(t + 256 * this[++e] + 65536 * this[++e] + this[++e] * 2 ** 24) })), l.prototype.readBigInt64BE = J((function (e) { M(e >>>= 0, "offset"); const t = this[e], r = this[e + 7]; void 0 !== t && void 0 !== r || D(e, this.length - 8); const n = (t << 24) + 65536 * this[++e] + 256 * this[++e] + this[++e]; return (BigInt(n) << BigInt(32)) + BigInt(this[++e] * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + r) })), l.prototype.readFloatLE = function (e, t) { return e >>>= 0, t || C(e, 4, this.length), o.read(this, e, !0, 23, 4) }, l.prototype.readFloatBE = function (e, t) { return e >>>= 0, t || C(e, 4, this.length), o.read(this, e, !1, 23, 4) }, l.prototype.readDoubleLE = function (e, t) { return e >>>= 0, t || C(e, 8, this.length), o.read(this, e, !0, 52, 8) }, l.prototype.readDoubleBE = function (e, t) { return e >>>= 0, t || C(e, 8, this.length), o.read(this, e, !1, 52, 8) }, l.prototype.writeUintLE = l.prototype.writeUIntLE = function (e, t, r, n) { e = +e, t >>>= 0, r >>>= 0, n || L(this, e, t, r, Math.pow(2, 8 * r) - 1, 0); let o = 1, i = 0; for (this[t] = 255 & e; ++i < r && (o *= 256);)this[t + i] = e / o & 255; return t + r }, l.prototype.writeUintBE = l.prototype.writeUIntBE = function (e, t, r, n) { e = +e, t >>>= 0, r >>>= 0, n || L(this, e, t, r, Math.pow(2, 8 * r) - 1, 0); let o = r - 1, i = 1; for (this[t + o] = 255 & e; --o >= 0 && (i *= 256);)this[t + o] = e / i & 255; return t + r }, l.prototype.writeUint8 = l.prototype.writeUInt8 = function (e, t, r) { return e = +e, t >>>= 0, r || L(this, e, t, 1, 255, 0), this[t] = 255 & e, t + 1 }, l.prototype.writeUint16LE = l.prototype.writeUInt16LE = function (e, t, r) { return e = +e, t >>>= 0, r || L(this, e, t, 2, 65535, 0), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2 }, l.prototype.writeUint16BE = l.prototype.writeUInt16BE = function (e, t, r) { return e = +e, t >>>= 0, r || L(this, e, t, 2, 65535, 0), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2 }, l.prototype.writeUint32LE = l.prototype.writeUInt32LE = function (e, t, r) { return e = +e, t >>>= 0, r || L(this, e, t, 4, 4294967295, 0), this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e, t + 4 }, l.prototype.writeUint32BE = l.prototype.writeUInt32BE = function (e, t, r) { return e = +e, t >>>= 0, r || L(this, e, t, 4, 4294967295, 0), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4 }, l.prototype.writeBigUInt64LE = J((function (e, t = 0) { return q(this, e, t, BigInt(0), BigInt("0xffffffffffffffff")) })), l.prototype.writeBigUInt64BE = J((function (e, t = 0) { return z(this, e, t, BigInt(0), BigInt("0xffffffffffffffff")) })), l.prototype.writeIntLE = function (e, t, r, n) { if (e = +e, t >>>= 0, !n) { const n = Math.pow(2, 8 * r - 1); L(this, e, t, r, n - 1, -n) } let o = 0, i = 1, s = 0; for (this[t] = 255 & e; ++o < r && (i *= 256);)e < 0 && 0 === s && 0 !== this[t + o - 1] && (s = 1), this[t + o] = (e / i >> 0) - s & 255; return t + r }, l.prototype.writeIntBE = function (e, t, r, n) { if (e = +e, t >>>= 0, !n) { const n = Math.pow(2, 8 * r - 1); L(this, e, t, r, n - 1, -n) } let o = r - 1, i = 1, s = 0; for (this[t + o] = 255 & e; --o >= 0 && (i *= 256);)e < 0 && 0 === s && 0 !== this[t + o + 1] && (s = 1), this[t + o] = (e / i >> 0) - s & 255; return t + r }, l.prototype.writeInt8 = function (e, t, r) { return e = +e, t >>>= 0, r || L(this, e, t, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[t] = 255 & e, t + 1 }, l.prototype.writeInt16LE = function (e, t, r) { return e = +e, t >>>= 0, r || L(this, e, t, 2, 32767, -32768), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2 }, l.prototype.writeInt16BE = function (e, t, r) { return e = +e, t >>>= 0, r || L(this, e, t, 2, 32767, -32768), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2 }, l.prototype.writeInt32LE = function (e, t, r) { return e = +e, t >>>= 0, r || L(this, e, t, 4, 2147483647, -2147483648), this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24, t + 4 }, l.prototype.writeInt32BE = function (e, t, r) { return e = +e, t >>>= 0, r || L(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4 }, l.prototype.writeBigInt64LE = J((function (e, t = 0) { return q(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff")) })), l.prototype.writeBigInt64BE = J((function (e, t = 0) { return z(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff")) })), l.prototype.writeFloatLE = function (e, t, r) { return W(this, e, t, !0, r) }, l.prototype.writeFloatBE = function (e, t, r) { return W(this, e, t, !1, r) }, l.prototype.writeDoubleLE = function (e, t, r) { return U(this, e, t, !0, r) }, l.prototype.writeDoubleBE = function (e, t, r) { return U(this, e, t, !1, r) }, l.prototype.copy = function (e, t, r, n) { if (!l.isBuffer(e)) throw new TypeError("argument should be a Buffer"); if (r || (r = 0), n || 0 === n || (n = this.length), t >= e.length && (t = e.length), t || (t = 0), n > 0 && n < r && (n = r), n === r) return 0; if (0 === e.length || 0 === this.length) return 0; if (t < 0) throw new RangeError("targetStart out of bounds"); if (r < 0 || r >= this.length) throw new RangeError("Index out of range"); if (n < 0) throw new RangeError("sourceEnd out of bounds"); n > this.length && (n = this.length), e.length - t < n - r && (n = e.length - t + r); const o = n - r; return this === e && "function" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(t, r, n) : Uint8Array.prototype.set.call(e, this.subarray(r, n), t), o }, l.prototype.fill = function (e, t, r, n) { if ("string" == typeof e) { if ("string" == typeof t ? (n = t, t = 0, r = this.length) : "string" == typeof r && (n = r, r = this.length), void 0 !== n && "string" != typeof n) throw new TypeError("encoding must be a string"); if ("string" == typeof n && !l.isEncoding(n)) throw new TypeError("Unknown encoding: " + n); if (1 === e.length) { const t = e.charCodeAt(0); ("utf8" === n && t < 128 || "latin1" === n) && (e = t) } } else "number" == typeof e ? e &= 255 : "boolean" == typeof e && (e = Number(e)); if (t < 0 || this.length < t || this.length < r) throw new RangeError("Out of range index"); if (r <= t) return this; let o; if (t >>>= 0, r = void 0 === r ? this.length : r >>> 0, e || (e = 0), "number" == typeof e) for (o = t; o < r; ++o)this[o] = e; else { const i = l.isBuffer(e) ? e : l.from(e, n), s = i.length; if (0 === s) throw new TypeError('The value "' + e + '" is invalid for argument "value"'); for (o = 0; o < r - t; ++o)this[o + t] = i[o % s] } return this }; const F = {}; function j(e, t, r) { F[e] = class extends r { constructor() { super(), Object.defineProperty(this, "message", { value: t.apply(this, arguments), writable: !0, configurable: !0 }), this.name = `${this.name} [${e}]`, this.stack, delete this.name } get code() { return e } set code(e) { Object.defineProperty(this, "code", { configurable: !0, enumerable: !0, value: e, writable: !0 }) } toString() { return `${this.name} [${e}]: ${this.message}` } } } function N(e) { let t = "", r = e.length; const n = "-" === e[0] ? 1 : 0; for (; r >= n + 4; r -= 3)t = `_${e.slice(r - 3, r)}${t}`; return `${e.slice(0, r)}${t}` } function $(e, t, r, n, o, i) { if (e > r || e < t) { const n = "bigint" == typeof t ? "n" : ""; let o; throw o = i > 3 ? 0 === t || t === BigInt(0) ? `>= 0${n} and < 2${n} ** ${8 * (i + 1)}${n}` : `>= -(2${n} ** ${8 * (i + 1) - 1}${n}) and < 2 ** ${8 * (i + 1) - 1}${n}` : `>= ${t}${n} and <= ${r}${n}`, new F.ERR_OUT_OF_RANGE("value", o, e) } !function (e, t, r) { M(t, "offset"), void 0 !== e[t] && void 0 !== e[t + r] || D(t, e.length - (r + 1)) }(n, o, i) } function M(e, t) { if ("number" != typeof e) throw new F.ERR_INVALID_ARG_TYPE(t, "number", e) } function D(e, t, r) { if (Math.floor(e) !== e) throw M(e, r), new F.ERR_OUT_OF_RANGE(r || "offset", "an integer", e); if (t < 0) throw new F.ERR_BUFFER_OUT_OF_BOUNDS; throw new F.ERR_OUT_OF_RANGE(r || "offset", `>= ${r ? 1 : 0} and <= ${t}`, e) } j("ERR_BUFFER_OUT_OF_BOUNDS", (function (e) { return e ? `${e} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds" }), RangeError), j("ERR_INVALID_ARG_TYPE", (function (e, t) { return `The "${e}" argument must be of type number. Received type ${typeof t}` }), TypeError), j("ERR_OUT_OF_RANGE", (function (e, t, r) { let n = `The value of "${e}" is out of range.`, o = r; return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? o = N(String(r)) : "bigint" == typeof r && (o = String(r), (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (o = N(o)), o += "n"), n += ` It must be ${t}. Received ${o}`, n }), RangeError); const V = /[^+/0-9A-Za-z-_]/g; function H(e, t) { let r; t = t || 1 / 0; const n = e.length; let o = null; const i = []; for (let s = 0; s < n; ++s) { if (r = e.charCodeAt(s), r > 55295 && r < 57344) { if (!o) { if (r > 56319) { (t -= 3) > -1 && i.push(239, 191, 189); continue } if (s + 1 === n) { (t -= 3) > -1 && i.push(239, 191, 189); continue } o = r; continue } if (r < 56320) { (t -= 3) > -1 && i.push(239, 191, 189), o = r; continue } r = 65536 + (o - 55296 << 10 | r - 56320) } else o && (t -= 3) > -1 && i.push(239, 191, 189); if (o = null, r < 128) { if ((t -= 1) < 0) break; i.push(r) } else if (r < 2048) { if ((t -= 2) < 0) break; i.push(r >> 6 | 192, 63 & r | 128) } else if (r < 65536) { if ((t -= 3) < 0) break; i.push(r >> 12 | 224, r >> 6 & 63 | 128, 63 & r | 128) } else { if (!(r < 1114112)) throw new Error("Invalid code point"); if ((t -= 4) < 0) break; i.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, 63 & r | 128) } } return i } function K(e) { return n.toByteArray(function (e) { if ((e = (e = e.split("=")[0]).trim().replace(V, "")).length < 2) return ""; for (; e.length % 4 != 0;)e += "="; return e }(e)) } function Y(e, t, r, n) { let o; for (o = 0; o < n && !(o + r >= t.length || o >= e.length); ++o)t[o + r] = e[o]; return o } function Q(e, t) { return e instanceof t || null != e && null != e.constructor && null != e.constructor.name && e.constructor.name === t.name } function G(e) { return e != e } const X = function () { const e = "0123456789abcdef", t = new Array(256); for (let r = 0; r < 16; ++r) { const n = 16 * r; for (let o = 0; o < 16; ++o)t[n + o] = e[r] + e[o] } return t }(); function J(e) { return "undefined" == typeof BigInt ? Z : e } function Z() { throw new Error("BigInt not supported") } }, 645: (e, t) => { t.read = function (e, t, r, n, o) { var i, s, a = 8 * o - n - 1, l = (1 << a) - 1, u = l >> 1, c = -7, d = r ? o - 1 : 0, h = r ? -1 : 1, f = e[t + d]; for (d += h, i = f & (1 << -c) - 1, f >>= -c, c += a; c > 0; i = 256 * i + e[t + d], d += h, c -= 8); for (s = i & (1 << -c) - 1, i >>= -c, c += n; c > 0; s = 256 * s + e[t + d], d += h, c -= 8); if (0 === i) i = 1 - u; else { if (i === l) return s ? NaN : 1 / 0 * (f ? -1 : 1); s += Math.pow(2, n), i -= u } return (f ? -1 : 1) * s * Math.pow(2, i - n) }, t.write = function (e, t, r, n, o, i) { var s, a, l, u = 8 * i - o - 1, c = (1 << u) - 1, d = c >> 1, h = 23 === o ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = n ? 0 : i - 1, p = n ? 1 : -1, b = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0; for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, s = c) : (s = Math.floor(Math.log(t) / Math.LN2), t * (l = Math.pow(2, -s)) < 1 && (s--, l *= 2), (t += s + d >= 1 ? h / l : h * Math.pow(2, 1 - d)) * l >= 2 && (s++, l /= 2), s + d >= c ? (a = 0, s = c) : s + d >= 1 ? (a = (t * l - 1) * Math.pow(2, o), s += d) : (a = t * Math.pow(2, d - 1) * Math.pow(2, o), s = 0)); o >= 8; e[r + f] = 255 & a, f += p, a /= 256, o -= 8); for (s = s << o | a, u += o; u > 0; e[r + f] = 255 & s, f += p, s /= 256, u -= 8); e[r + f - p] |= 128 * b } } }, t = {}; function r(n) { var o = t[n]; if (void 0 !== o) return o.exports; var i = t[n] = { exports: {} }; return e[n](i, i.exports, r), i.exports } (() => { "use strict"; var e = function () { function e() { var e = this; this._state = "running", this.resolve = function (t) { e._resolve(t), e._state = "resolved" }, this.reject = function (t) { e._reject(t), e._state = "rejected" }, this._promise = new Promise((function (t, r) { e._resolve = t, e._reject = r })) } return Object.defineProperty(e.prototype, "promise", { get: function () { return this._promise }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "state", { get: function () { return this._state }, enumerable: !1, configurable: !0 }), e }(), t = function () { function t(e) { void 0 === e && (e = 0), this.pendingResolvers = new Map, this.nextId = e } return t.prototype.add = function () { var t = this.nextId++, r = new e; return this.pendingResolvers.set(t, r), [t, r.promise] }, t.prototype.getResolver = function (e) { if (!this.pendingResolvers.has(e)) return null; var t = this.pendingResolvers.get(e); return this.pendingResolvers.delete(e), t }, t.prototype.resolve = function (e, t) { var r = this.getResolver(e); return null !== r && (r.resolve(t), !0) }, t.prototype.reject = function (e, t) { var r = this.getResolver(e); return null !== r && (r.reject(t), !0) }, t }(); const n = BigInt(32), o = "getBigInt64" in DataView.prototype ? (e, t, r) => e.getBigInt64(t, r) : function (e, t, r) { const o = Number(!!r), i = Number(!r); return BigInt(e.getInt32(t, r) * i + e.getInt32(t + 4, r) * o) << n | BigInt(e.getUint32(t, r) * o + e.getUint32(t + 4, r) * i) }, i = "getBigUint64" in DataView.prototype ? (e, t, r) => e.getBigUint64(t, r) : function (e, t, r) { const o = e.getUint32(t, r), i = e.getUint32(t + 4, r), s = Number(!!r), a = Number(!r); return BigInt(o * a + i * s) << n | BigInt(o * s + i * a) }, s = "setBigInt64" in DataView.prototype ? (e, t, r, n) => e.setBigInt64(t, r, n) : function (e, t, r, o) { const i = Number(r >> n), s = Number(r & BigInt(4294967295)); o ? (e.setInt32(t + 4, i, o), e.setUint32(t, s, o)) : (e.setInt32(t, i, o), e.setUint32(t + 4, s, o)) }, a = "setBigUint64" in DataView.prototype ? (e, t, r, n) => e.setBigUint64(t, r, n) : function (e, t, r, o) { const i = Number(r >> n), s = Number(r & BigInt(4294967295)); o ? (e.setUint32(t + 4, i, o), e.setUint32(t, s, o)) : (e.setUint32(t, i, o), e.setUint32(t + 4, s, o)) }, l = BigInt(0), u = BigInt(1), c = BigInt(2), d = BigInt(64); function h(e, t, r) { let n = l; for (let o = t; o < t + r; o += 8)n <<= d, n += i(e, o, !1); return n } function f(e, t, r, n) { const o = t; if (n) for (; r > l;)a(e, t, r, !0), t += 8, r >>= d; else { const n = []; for (; r > l;)n.push(BigInt.asUintN(64, r)), r >>= d; for (let r = n.length - 1; r >= 0; r -= 1)a(e, t, n[r], !1), t += 8 } return t - o } function p(e) { const t = new DataView(e.buffer, e.byteOffset, e.byteLength); return [h(t, 38, 256), h(t, 303, 256)] } function b(e, t) { const [r] = p(e); let n; if (t) { if (t.byteLength < 524) throw new Error("output buffer is too small"); n = "number" } else t = new Uint8Array(524), n = "Uint8Array"; const o = new DataView(t.buffer, t.byteOffset, t.byteLength); let i = 0; o.setUint32(i, 64, !0), i += 4; const s = function (e, t) { if (!(e = (e % t + t) % t)) return NaN; const r = []; let n = t; for (; n;) [e, n] = [n, e % n], r.push({ a: e, b: n }); if (1 !== e) return NaN; let o = 1, i = 0; for (let e = r.length - 2; e >= 0; --e) [o, i] = [i, o - i * Math.floor(r[e].a / r[e].b)]; return (i % t + t) % t }(Number(BigInt.asUintN(32, r) * BigInt(-1)), 2 ** 32); return o.setUint32(i, s, !0), i += 4, f(o, i, r, !0), i += 256, i += f(o, i, BigInt(2) ** BigInt(4096) % r, !0), o.setUint32(i, 65537, !0), i += 4, "Uint8Array" === n ? t : 524 } const y = new Uint8Array([48, 33, 48, 9, 6, 5, 43, 14, 3, 2, 26, 5, 0, 4, 20]); function g(e, t) { const [r, n] = p(e), o = new Uint8Array(256); let i = 0; o[i] = 0, i += 1, o[i] = 1, i += 1; const s = o.length - y.length - t.length - 1; for (; i < s;)o[i] = 255, i += 1; o[i] = 0, i += 1, o.set(y, i), i += y.length, o.set(t, i); const a = new DataView(o.buffer), d = function (e, t, r) { if (r === u) return l; let n = u; for (e %= r; t > l;)BigInt.asUintN(1, t) === u && (n = n * e % r), t >>= u, e = e ** c % r; return n }(h(a, 0, a.byteLength), n, r); return f(a, 0, d, !1), o } class w { TValue; TOmitInitKey; options; constructor(e) { this.options = e } } class _ { definition; options; struct; get hasCustomAccessors() { return this.get !== _.prototype.get || this.set !== _.prototype.set } value; constructor(e, t, r, n) { this.definition = e, this.options = t, this.struct = r, this.value = n } getSize() { return this.definition.getSize() } get() { return this.value } set(e) { this.value = e } } const m = { littleEndian: !1 }, v = Symbol("struct-value"); class S { fieldValues = {}; value; constructor(e) { this.value = Object.create(e), Object.defineProperty(this.value, v, { enumerable: !1, value: this }) } set(e, t) { this.fieldValues[e] = t, t.hasCustomAccessors ? Object.defineProperty(this.value, e, { configurable: !0, enumerable: !0, get: () => t.get(), set(e) { t.set(e) } }) : this.value[e] = t.get() } get(e) { return this.fieldValues[e] } } const E = { reject: e => new k(e), resolve: e => "object" == typeof e && null !== e && "function" == typeof e.then ? e instanceof R || e instanceof T || e instanceof k ? e : new R(e) : new T(e), try(e) { try { return E.resolve(e()) } catch (e) { return E.reject(e) } } }; class R { promise; constructor(e) { this.promise = e } then(e, t) { return new R(this.promise.then(e, t)) } valueOrPromise() { return this.promise } } class T { value; constructor(e) { this.value = e } then(e, t) { return e ? E.try((() => e(this.value))) : this } valueOrPromise() { return this.value } } class k { reason; constructor(e) { this.reason = e } then(e, t) { return t ? E.try((() => t(this.reason))) : this } valueOrPromise() { throw this.reason } } class A { TTypeScriptType; size; getter; setter; constructor(e, t, r) { this.size = e, this.getter = t, this.setter = r } static Int64 = new A(8, o, s); static Uint64 = new A(8, i, a) } class I extends w { type; constructor(e, t) { super(), this.type = e } getSize() { return this.type.size } create(e, t, r) { return new O(this, e, t, r) } deserialize(e, t, r) { return E.try((() => t.read(this.getSize()))).then((t => { const n = new DataView(t.buffer, t.byteOffset, t.byteLength), o = this.type.getter(n, 0, e.littleEndian); return this.create(e, r, o) })).valueOrPromise() } } class O extends _ { serialize(e, t) { this.definition.type.setter(e, t, this.value, this.options.littleEndian) } } const P = new TextEncoder, B = new TextDecoder; function C(e) { return P.encode(e) } function L(e) { return B.decode(e) } class q { TTypeScriptType } class z extends q { static Instance = new z; constructor() { super() } toBuffer(e) { return e } toValue(e) { return e } getSize(e) { return e.byteLength } } class x extends q { static Instance = new x; toBuffer(e) { return C(e) } toValue(e) { return L(e) } getSize() { return -1 } } const W = new Uint8Array(0); class U extends w { type; constructor(e, t) { super(t), this.type = e } getDeserializeSize(e) { return this.getSize() } create(e, t, r, n) { return new F(this, e, t, r, n) } deserialize(e, t, r) { return E.try((() => { const e = this.getDeserializeSize(r); return 0 === e ? W : t.read(e) })).then((t => { const n = this.type.toValue(t); return this.create(e, r, n, t) })).valueOrPromise() } } class F extends _ { array; constructor(e, t, r, n, o) { super(e, t, r, n), this.array = o } set(e) { super.set(e), this.array = void 0 } serialize(e, t) { this.array || (this.array = this.definition.type.toBuffer(this.value)), new Uint8Array(e.buffer, e.byteOffset, e.byteLength).set(this.array, t) } } class j extends U { getSize() { return this.options.length } } class N extends U { getSize() { return 0 } getDeserializeSize(e) { let t = e.value[this.options.lengthField]; return "string" == typeof t && (t = Number.parseInt(t, this.options.lengthFieldRadix ?? 10)), t } create(e, t, r, n) { return new $(this, e, t, r, n) } } class $ extends F { length; lengthFieldValue; constructor(e, t, r, n, o) { super(e, t, r, n, o), o && (this.length = o.byteLength); const i = this.definition.options.lengthField, s = r.get(i); this.lengthFieldValue = new M(s, this), r.set(i, this.lengthFieldValue) } getSize() { return void 0 === this.length && (this.length = this.definition.type.getSize(this.value), -1 === this.length && (this.array = this.definition.type.toBuffer(this.value), this.length = this.array.byteLength)), this.length } set(e) { super.set(e), this.array = void 0, this.length = void 0 } } class M extends _ { originalField; bufferField; constructor(e, t) { super(e.definition, e.options, e.struct, 0), this.originalField = e, this.bufferField = t } getSize() { return this.originalField.getSize() } get() { let e = this.bufferField.getSize(); return "string" == typeof this.originalField.get() && (e = e.toString(this.bufferField.definition.options.lengthFieldRadix ?? 10)), e } set() { } serialize(e, t) { this.originalField.set(this.get()), this.originalField.serialize(e, t) } } const D = { 1: (e, t) => e[0], 2: (e, t) => (e[1] << 8 | e[0]) * t | (e[0] << 8 | e[1]) * !t, 4: (e, t) => (e[3] << 24 | e[2] << 16 | e[1] << 8 | e[0]) * t | (e[0] << 24 | e[1] << 16 | e[2] << 8 | e[3]) * !t }; class V { TTypeScriptType; signed; size; deserializer; convertSign; dataViewSetter; constructor(e, t, r, n) { this.size = e, this.signed = t, this.deserializer = D[e], this.convertSign = r, this.dataViewSetter = n } static Int8 = new V(1, !0, (e => e << 24 >> 24), "setInt8"); static Uint8 = new V(1, !1, (e => e), "setUint8"); static Int16 = new V(2, !0, (e => e << 16 >> 16), "setInt16"); static Uint16 = new V(2, !1, (e => e), "setUint16"); static Int32 = new V(4, !0, (e => e), "setInt32"); static Uint32 = new V(4, !1, (e => e >>> 0), "setUint32") } class H extends w { type; constructor(e, t) { super(), this.type = e } getSize() { return this.type.size } create(e, t, r) { return new K(this, e, t, r) } deserialize(e, t, r) { return E.try((() => t.read(this.getSize()))).then((t => { let n; return n = this.type.deserializer(t, e.littleEndian), n = this.type.convertSign(n), this.create(e, r, n) })).valueOrPromise() } } class K extends _ { serialize(e, t) { e[this.definition.type.dataViewSetter](t, this.value, this.options.littleEndian) } } class Y { TFields; TOmitInitKey; TExtra; TInit; TDeserializeResult; options; _size = 0; get size() { return this._size } _fields = []; _extra = {}; _postDeserialized; constructor(e) { this.options = { ...m, ...e } } field(e, t) { for (const t of this._fields) if (t[0] === e) throw new Error(`This struct already have a field with name '${String(e)}'`); this._fields.push([e, t]); const r = t.getSize(); return this._size += r, this } fields(e) { for (const t of e._fields) this._fields.push(t); return this._size += e._size, Object.defineProperties(this._extra, Object.getOwnPropertyDescriptors(e._extra)), this } number(e, t, r) { return this.field(e, new H(t, r)) } int8(e, t) { return this.number(e, V.Int8, t) } uint8(e, t) { return this.number(e, V.Uint8, t) } int16(e, t) { return this.number(e, V.Int16, t) } uint16(e, t) { return this.number(e, V.Uint16, t) } int32(e, t) { return this.number(e, V.Int32, t) } uint32(e, t) { return this.number(e, V.Uint32, t) } bigint(e, t, r) { return this.field(e, new I(t, r)) } int64(e, t) { return this.bigint(e, A.Int64, t) } uint64(e, t) { return this.bigint(e, A.Uint64, t) } arrayBufferLike = (e, t, r) => "length" in r ? this.field(e, new j(t, r)) : this.field(e, new N(t, r)); uint8Array = (e, t, r) => this.arrayBufferLike(e, z.Instance, t, r); string = (e, t, r) => this.arrayBufferLike(e, x.Instance, t, r); extra(e) { return Object.defineProperties(this._extra, Object.getOwnPropertyDescriptors(e)), this } postDeserialize(e) { return this._postDeserialized = e, this } deserialize(e) { const t = new S(this._extra); let r = E.resolve(); for (const [n, o] of this._fields) r = r.then((() => o.deserialize(this.options, e, t))).then((e => { t.set(n, e) })); return r.then((() => { const e = t.value; if (this._postDeserialized) { const t = this._postDeserialized.call(e, e); if (t) return t } return e })).valueOrPromise() } serialize(e, t) { let r; if (v in e) { r = e[v]; for (const [t, n] of Object.entries(e)) { const e = r.get(t); e && e.set(n) } } else { r = new S({}); for (const [t, n] of this._fields) { const o = n.create(this.options, r, e[t]); r.set(t, o) } } let n = 0; const o = []; for (const [e] of this._fields) { const t = r.get(e), i = t.getSize(); o.push({ fieldValue: t, size: i }), n += i } let i = "number"; t || (t = new Uint8Array(n), i = "Uint8Array"); const s = new DataView(t.buffer, t.byteOffset, t.byteLength); let a = 0; for (const { fieldValue: e, size: t } of o) e.serialize(s, a), a += t; return "number" === i ? n : t } } class Q { list = []; blocking; constructor(e = !1) { this.blocking = e } wait() { if (!this.blocking && (this.blocking = !0, 0 === this.list.length)) return Promise.resolve(); const t = new e; return this.list.push(t), t.promise } notify() { 0 !== this.list.length ? this.list.pop().resolve() : this.blocking = !1 } dispose() { for (const e of this.list) e.reject(new Error("The AutoResetEvent has been disposed")); this.list.length = 0 } } const G = {}, X = [], J = "=".charCodeAt(0); function Z(e, t) { const r = e.charCodeAt(0), n = t.charCodeAt(0); for (let e = r; e <= n; e += 1)G[String.fromCharCode(e)] = X.length, X.push(e) } function ee(e) { const t = e % 3, r = 0 !== t ? 3 - t : 0; return [(e + r) / 3 * 4, r] } function te(e, t) { const [r, n] = ee(e.length); if (t) { if (t.length < r) throw new Error("output buffer is too small"); if (t = t.subarray(0, r), e.buffer !== t.buffer) re(e, t, n); else if (t.byteOffset + t.length - (n + 1) <= e.byteOffset + e.length) re(e, t, n); else { if (!(t.byteOffset >= e.byteOffset - 1)) throw new Error("input and output cannot overlap"); !function (e, t, r) { let n = e.length - 1, o = t.length - 1; if (2 === r) { const r = e[n]; n -= 1, t[o] = J, o -= 1, t[o] = J, o -= 1, t[o] = X[(3 & r) << 4], o -= 1, t[o] = X[r >> 2], o -= 1 } else if (1 === r) { const r = e[n]; n -= 1; const i = e[n]; n -= 1, t[o] = J, o -= 1, t[o] = X[(15 & r) << 2], o -= 1, t[o] = X[(3 & i) << 4 | r >> 4], o -= 1, t[o] = X[i >> 2], o -= 1 } for (; n >= 0;) { const r = e[n]; n -= 1; const i = e[n]; n -= 1; const s = e[n]; n -= 1, t[o] = X[63 & r], o -= 1, t[o] = X[(15 & i) << 2 | r >> 6], o -= 1, t[o] = X[(3 & s) << 4 | i >> 4], o -= 1, t[o] = X[s >> 2], o -= 1 } }(e, t, n) } return r } return re(e, t = new Uint8Array(r), n), t } function re(e, t, r) { let n = 0, o = 0; for (; n < e.length - 2;) { const r = e[n]; n += 1; const i = e[n]; n += 1; const s = e[n]; n += 1, t[o] = X[r >> 2], o += 1, t[o] = X[(3 & r) << 4 | i >> 4], o += 1, t[o] = X[(15 & i) << 2 | s >> 6], o += 1, t[o] = X[63 & s], o += 1 } if (2 === r) { const r = e[n]; n += 1, t[o] = X[r >> 2], o += 1, t[o] = X[(3 & r) << 4], o += 1, t[o] = J, o += 1, t[o] = J } else if (1 === r) { const r = e[n]; n += 1; const i = e[n]; n += 1, t[o] = X[r >> 2], o += 1, t[o] = X[(3 & r) << 4 | i >> 4], o += 1, t[o] = X[(15 & i) << 2], o += 1, t[o] = J } } Z("A", "Z"), Z("a", "z"), Z("0", "9"), Z("+", "+"), Z("/", "/"); const ne = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? Symbol : e => `Symbol(${e})`; function oe() { } function ie(e) { return "object" == typeof e && null !== e || "function" == typeof e } const se = oe; function ae(e, t) { try { Object.defineProperty(e, "name", { value: t, configurable: !0 }) } catch (e) { } } const le = Promise, ue = Promise.prototype.then, ce = Promise.resolve.bind(le), de = Promise.reject.bind(le); function he(e) { return new le(e) } function fe(e) { return ce(e) } function pe(e) { return de(e) } function be(e, t, r) { return ue.call(e, t, r) } function ye(e, t, r) { be(be(e, t, r), void 0, se) } function ge(e, t) { ye(e, t) } function we(e, t) { ye(e, void 0, t) } function _e(e, t, r) { return be(e, t, r) } function me(e) { be(e, void 0, se) } let ve = e => { if ("function" == typeof queueMicrotask) ve = queueMicrotask; else { const e = fe(void 0); ve = t => be(e, t) } return ve(e) }; function Se(e, t, r) { if ("function" != typeof e) throw new TypeError("Argument is not a function"); return Function.prototype.apply.call(e, t, r) } function Ee(e, t, r) { try { return fe(Se(e, t, r)) } catch (e) { return pe(e) } } class Re { constructor() { this._cursor = 0, this._size = 0, this._front = { _elements: [], _next: void 0 }, this._back = this._front, this._cursor = 0, this._size = 0 } get length() { return this._size } push(e) { const t = this._back; let r = t; 16383 === t._elements.length && (r = { _elements: [], _next: void 0 }), t._elements.push(e), r !== t && (this._back = r, t._next = r), ++this._size } shift() { const e = this._front; let t = e; const r = this._cursor; let n = r + 1; const o = e._elements, i = o[r]; return 16384 === n && (t = e._next, n = 0), --this._size, this._cursor = n, e !== t && (this._front = t), o[r] = void 0, i } forEach(e) { let t = this._cursor, r = this._front, n = r._elements; for (; !(t === n.length && void 0 === r._next || t === n.length && (r = r._next, n = r._elements, t = 0, 0 === n.length));)e(n[t]), ++t } peek() { const e = this._front, t = this._cursor; return e._elements[t] } } const Te = ne("[[AbortSteps]]"), ke = ne("[[ErrorSteps]]"), Ae = ne("[[CancelSteps]]"), Ie = ne("[[PullSteps]]"), Oe = ne("[[ReleaseSteps]]"); function Pe(e, t) { e._ownerReadableStream = t, t._reader = e, "readable" === t._state ? qe(e) : "closed" === t._state ? function (e) { qe(e), We(e) }(e) : ze(e, t._storedError) } function Be(e, t) { return nn(e._ownerReadableStream, t) } function Ce(e) { const t = e._ownerReadableStream; "readable" === t._state ? xe(e, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")) : function (e, t) { ze(e, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")) }(e), t._readableStreamController[Oe](), t._reader = void 0, e._ownerReadableStream = void 0 } function Le(e) { return new TypeError("Cannot " + e + " a stream using a released reader") } function qe(e) { e._closedPromise = he(((t, r) => { e._closedPromise_resolve = t, e._closedPromise_reject = r })) } function ze(e, t) { qe(e), xe(e, t) } function xe(e, t) { void 0 !== e._closedPromise_reject && (me(e._closedPromise), e._closedPromise_reject(t), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0) } function We(e) { void 0 !== e._closedPromise_resolve && (e._closedPromise_resolve(void 0), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0) } const Ue = Number.isFinite || function (e) { return "number" == typeof e && isFinite(e) }, Fe = Math.trunc || function (e) { return e < 0 ? Math.ceil(e) : Math.floor(e) }; function je(e, t) { if (void 0 !== e && "object" != typeof (r = e) && "function" != typeof r) throw new TypeError(`${t} is not an object.`); var r } function Ne(e, t) { if ("function" != typeof e) throw new TypeError(`${t} is not a function.`) } function $e(e, t) { if (!function (e) { return "object" == typeof e && null !== e || "function" == typeof e }(e)) throw new TypeError(`${t} is not an object.`) } function Me(e, t, r) { if (void 0 === e) throw new TypeError(`Parameter ${t} is required in '${r}'.`) } function De(e, t, r) { if (void 0 === e) throw new TypeError(`${t} is required in '${r}'.`) } function Ve(e) { return Number(e) } function He(e) { return 0 === e ? 0 : e } function Ke(e, t) { const r = Number.MAX_SAFE_INTEGER; let n = Number(e); if (n = He(n), !Ue(n)) throw new TypeError(`${t} is not a finite number`); if (n = function (e) { return He(Fe(e)) }(n), n < 0 || n > r) throw new TypeError(`${t} is outside the accepted range of 0 to ${r}, inclusive`); return Ue(n) && 0 !== n ? n : 0 } function Ye(e) { if (!ie(e)) return !1; if ("function" != typeof e.getReader) return !1; try { return "boolean" == typeof e.locked } catch (e) { return !1 } } function Qe(e) { if (!ie(e)) return !1; if ("function" != typeof e.getWriter) return !1; try { return "boolean" == typeof e.locked } catch (e) { return !1 } } function Ge(e, t) { if (!tn(e)) throw new TypeError(`${t} is not a ReadableStream.`) } function Xe(e, t) { e._reader._readRequests.push(t) } function Je(e, t, r) { const n = e._reader._readRequests.shift(); r ? n._closeSteps() : n._chunkSteps(t) } function Ze(e) { return e._reader._readRequests.length } function et(e) { const t = e._reader; return void 0 !== t && !!rt(t) } class tt { constructor(e) { if (Me(e, 1, "ReadableStreamDefaultReader"), Ge(e, "First parameter"), rn(e)) throw new TypeError("This stream has already been locked for exclusive reading by another reader"); Pe(this, e), this._readRequests = new Re } get closed() { return rt(this) ? this._closedPromise : pe(ot("closed")) } cancel(e) { return rt(this) ? void 0 === this._ownerReadableStream ? pe(Le("cancel")) : Be(this, e) : pe(ot("cancel")) } read() { if (!rt(this)) return pe(ot("read")); if (void 0 === this._ownerReadableStream) return pe(Le("read from")); let e, t; const r = he(((r, n) => { e = r, t = n })); return function (e, t) { const r = e._ownerReadableStream; r._disturbed = !0, "closed" === r._state ? t._closeSteps() : "errored" === r._state ? t._errorSteps(r._storedError) : r._readableStreamController[Ie](t) }(this, { _chunkSteps: t => e({ value: t, done: !1 }), _closeSteps: () => e({ value: void 0, done: !0 }), _errorSteps: e => t(e) }), r } releaseLock() { if (!rt(this)) throw ot("releaseLock"); void 0 !== this._ownerReadableStream && function (e) { Ce(e), nt(e, new TypeError("Reader was released")) }(this) } } function rt(e) { return !!ie(e) && !!Object.prototype.hasOwnProperty.call(e, "_readRequests") && e instanceof tt } function nt(e, t) { const r = e._readRequests; e._readRequests = new Re, r.forEach((e => { e._errorSteps(t) })) } function ot(e) { return new TypeError(`ReadableStreamDefaultReader.prototype.${e} can only be used on a ReadableStreamDefaultReader`) } Object.defineProperties(tt.prototype, { cancel: { enumerable: !0 }, read: { enumerable: !0 }, releaseLock: { enumerable: !0 }, closed: { enumerable: !0 } }), ae(tt.prototype.cancel, "cancel"), ae(tt.prototype.read, "read"), ae(tt.prototype.releaseLock, "releaseLock"), "symbol" == typeof ne.toStringTag && Object.defineProperty(tt.prototype, ne.toStringTag, { value: "ReadableStreamDefaultReader", configurable: !0 }); class it { constructor(e, t) { this._ongoingPromise = void 0, this._isFinished = !1, this._reader = e, this._preventCancel = t } next() { const e = () => this._nextSteps(); return this._ongoingPromise = this._ongoingPromise ? _e(this._ongoingPromise, e, e) : e(), this._ongoingPromise } return(e) { const t = () => this._returnSteps(e); return this._ongoingPromise ? _e(this._ongoingPromise, t, t) : t() } _nextSteps() { if (this._isFinished) return Promise.resolve({ value: void 0, done: !0 }); const e = this._reader; return void 0 === e ? pe(Le("iterate")) : be(e.read(), (e => { var t; return this._ongoingPromise = void 0, e.done && (this._isFinished = !0, null === (t = this._reader) || void 0 === t || t.releaseLock(), this._reader = void 0), e }), (e => { var t; throw this._ongoingPromise = void 0, this._isFinished = !0, null === (t = this._reader) || void 0 === t || t.releaseLock(), this._reader = void 0, e })) } _returnSteps(e) { if (this._isFinished) return Promise.resolve({ value: e, done: !0 }); this._isFinished = !0; const t = this._reader; if (void 0 === t) return pe(Le("finish iterating")); if (this._reader = void 0, !this._preventCancel) { const r = t.cancel(e); return t.releaseLock(), _e(r, (() => ({ value: e, done: !0 }))) } return t.releaseLock(), fe({ value: e, done: !0 }) } } const st = { next() { return at(this) ? this._asyncIteratorImpl.next() : pe(lt("next")) }, return(e) { return at(this) ? this._asyncIteratorImpl.return(e) : pe(lt("return")) } }; function at(e) { if (!ie(e)) return !1; if (!Object.prototype.hasOwnProperty.call(e, "_asyncIteratorImpl")) return !1; try { return e._asyncIteratorImpl instanceof it } catch (e) { return !1 } } function lt(e) { return new TypeError(`ReadableStreamAsyncIterator.${e} can only be used on a ReadableSteamAsyncIterator`) } "symbol" == typeof ne.asyncIterator && Object.defineProperty(st, ne.asyncIterator, { value() { return this }, writable: !0, configurable: !0 }); const ut = Number.isNaN || function (e) { return e != e }; function ct(e, t, r, n, o) { new Uint8Array(e).set(new Uint8Array(r, n, o), t) } function dt(e) { const t = function (e, t, r) { if (e.slice) return e.slice(t, r); const n = r - t, o = new ArrayBuffer(n); return ct(o, 0, e, t, n), o }(e.buffer, e.byteOffset, e.byteOffset + e.byteLength); return new Uint8Array(t) } function ht(e) { const t = e._queue.shift(); return e._queueTotalSize -= t.size, e._queueTotalSize < 0 && (e._queueTotalSize = 0), t.value } function ft(e, t, r) { if ("number" != typeof (n = r) || ut(n) || n < 0 || r === 1 / 0) throw new RangeError("Size must be a finite, non-NaN, non-negative number."); var n; e._queue.push({ value: t, size: r }), e._queueTotalSize += r } function pt(e) { e._queue = new Re, e._queueTotalSize = 0 } class bt { constructor() { throw new TypeError("Illegal constructor") } get view() { if (!wt(this)) throw Wt("view"); return this._view } respond(e) { if (!wt(this)) throw Wt("respond"); if (Me(e, 1, "respond"), e = Ke(e, "First parameter"), void 0 === this._associatedReadableByteStreamController) throw new TypeError("This BYOB request has been invalidated"); this._view.buffer, function (e, t) { const r = e._pendingPullIntos.peek(); if ("closed" === e._controlledReadableByteStream._state) { if (0 !== t) throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream") } else { if (0 === t) throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream"); if (r.bytesFilled + t > r.byteLength) throw new RangeError("bytesWritten out of range") } r.buffer = r.buffer, Bt(e, t) }(this._associatedReadableByteStreamController, e) } respondWithNewView(e) { if (!wt(this)) throw Wt("respondWithNewView"); if (Me(e, 1, "respondWithNewView"), !ArrayBuffer.isView(e)) throw new TypeError("You can only respond with array buffer views"); if (void 0 === this._associatedReadableByteStreamController) throw new TypeError("This BYOB request has been invalidated"); e.buffer, function (e, t) { const r = e._pendingPullIntos.peek(); if ("closed" === e._controlledReadableByteStream._state) { if (0 !== t.byteLength) throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream") } else if (0 === t.byteLength) throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream"); if (r.byteOffset + r.bytesFilled !== t.byteOffset) throw new RangeError("The region specified by view does not match byobRequest"); if (r.bufferByteLength !== t.buffer.byteLength) throw new RangeError("The buffer of view has different capacity than byobRequest"); if (r.bytesFilled + t.byteLength > r.byteLength) throw new RangeError("The region specified by view is larger than byobRequest"); const n = t.byteLength; r.buffer = t.buffer, Bt(e, n) }(this._associatedReadableByteStreamController, e) } } Object.defineProperties(bt.prototype, { respond: { enumerable: !0 }, respondWithNewView: { enumerable: !0 }, view: { enumerable: !0 } }), ae(bt.prototype.respond, "respond"), ae(bt.prototype.respondWithNewView, "respondWithNewView"), "symbol" == typeof ne.toStringTag && Object.defineProperty(bt.prototype, ne.toStringTag, { value: "ReadableStreamBYOBRequest", configurable: !0 }); class yt { constructor() { throw new TypeError("Illegal constructor") } get byobRequest() { if (!gt(this)) throw Ut("byobRequest"); return function (e) { if (null === e._byobRequest && e._pendingPullIntos.length > 0) { const t = e._pendingPullIntos.peek(), r = new Uint8Array(t.buffer, t.byteOffset + t.bytesFilled, t.byteLength - t.bytesFilled), n = Object.create(bt.prototype); !function (e, t, r) { e._associatedReadableByteStreamController = t, e._view = r }(n, e, r), e._byobRequest = n } return e._byobRequest }(this) } get desiredSize() { if (!gt(this)) throw Ut("desiredSize"); return xt(this) } close() { if (!gt(this)) throw Ut("close"); if (this._closeRequested) throw new TypeError("The stream has already been closed; do not close it again!"); const e = this._controlledReadableByteStream._state; if ("readable" !== e) throw new TypeError(`The stream (in ${e} state) is not in the readable state and cannot be closed`); !function (e) { const t = e._controlledReadableByteStream; if (!e._closeRequested && "readable" === t._state) if (e._queueTotalSize > 0) e._closeRequested = !0; else { if (e._pendingPullIntos.length > 0 && e._pendingPullIntos.peek().bytesFilled > 0) { const t = new TypeError("Insufficient bytes to fill elements in the given buffer"); throw qt(e, t), t } Lt(e), on(t) } }(this) } enqueue(e) { if (!gt(this)) throw Ut("enqueue"); if (Me(e, 1, "enqueue"), !ArrayBuffer.isView(e)) throw new TypeError("chunk must be an array buffer view"); if (0 === e.byteLength) throw new TypeError("chunk must have non-zero byteLength"); if (0 === e.buffer.byteLength) throw new TypeError("chunk's buffer must have non-zero byteLength"); if (this._closeRequested) throw new TypeError("stream is closed or draining"); const t = this._controlledReadableByteStream._state; if ("readable" !== t) throw new TypeError(`The stream (in ${t} state) is not in the readable state and cannot be enqueued to`); !function (e, t) { const r = e._controlledReadableByteStream; if (e._closeRequested || "readable" !== r._state) return; const n = t.buffer, o = t.byteOffset, i = t.byteLength, s = n; if (e._pendingPullIntos.length > 0) { const t = e._pendingPullIntos.peek(); t.buffer, Ot(e), t.buffer = t.buffer, "none" === t.readerType && Tt(e, t) } et(r) ? (function (e) { const t = e._controlledReadableByteStream._reader; for (; t._readRequests.length > 0;) { if (0 === e._queueTotalSize) return; zt(e, t._readRequests.shift()) } }(e), 0 === Ze(r) ? Et(e, s, o, i) : (e._pendingPullIntos.length > 0 && Ct(e), Je(r, new Uint8Array(s, o, i), !1))) : Nt(r) ? (Et(e, s, o, i), Pt(e)) : Et(e, s, o, i), _t(e) }(this, e) } error(e) { if (!gt(this)) throw Ut("error"); qt(this, e) } [Ae](e) { mt(this), pt(this); const t = this._cancelAlgorithm(e); return Lt(this), t } [Ie](e) { const t = this._controlledReadableByteStream; if (this._queueTotalSize > 0) return void zt(this, e); const r = this._autoAllocateChunkSize; if (void 0 !== r) { let n; try { n = new ArrayBuffer(r) } catch (t) { return void e._errorSteps(t) } const o = { buffer: n, bufferByteLength: r, byteOffset: 0, byteLength: r, bytesFilled: 0, elementSize: 1, viewConstructor: Uint8Array, readerType: "default" }; this._pendingPullIntos.push(o) } Xe(t, e), _t(this) } [Oe]() { if (this._pendingPullIntos.length > 0) { const e = this._pendingPullIntos.peek(); e.readerType = "none", this._pendingPullIntos = new Re, this._pendingPullIntos.push(e) } } } function gt(e) { return !!ie(e) && !!Object.prototype.hasOwnProperty.call(e, "_controlledReadableByteStream") && e instanceof yt } function wt(e) { return !!ie(e) && !!Object.prototype.hasOwnProperty.call(e, "_associatedReadableByteStreamController") && e instanceof bt } function _t(e) { const t = function (e) { const t = e._controlledReadableByteStream; return "readable" === t._state && !e._closeRequested && !!e._started && (!!(et(t) && Ze(t) > 0) || !!(Nt(t) && jt(t) > 0) || xt(e) > 0) }(e); t && (e._pulling ? e._pullAgain = !0 : (e._pulling = !0, ye(e._pullAlgorithm(), (() => (e._pulling = !1, e._pullAgain && (e._pullAgain = !1, _t(e)), null)), (t => (qt(e, t), null))))) } function mt(e) { Ot(e), e._pendingPullIntos = new Re } function vt(e, t) { let r = !1; "closed" === e._state && (r = !0); const n = St(t); "default" === t.readerType ? Je(e, n, r) : function (e, t, r) { const n = e._reader._readIntoRequests.shift(); r ? n._closeSteps(t) : n._chunkSteps(t) }(e, n, r) } function St(e) { const t = e.bytesFilled, r = e.elementSize; return new e.viewConstructor(e.buffer, e.byteOffset, t / r) } function Et(e, t, r, n) { e._queue.push({ buffer: t, byteOffset: r, byteLength: n }), e._queueTotalSize += n } function Rt(e, t, r, n) { let o; try { o = t.slice(r, r + n) } catch (t) { throw qt(e, t), t } Et(e, o, 0, n) } function Tt(e, t) { t.bytesFilled > 0 && Rt(e, t.buffer, t.byteOffset, t.bytesFilled), Ct(e) } function kt(e, t) { const r = t.elementSize, n = t.bytesFilled - t.bytesFilled % r, o = Math.min(e._queueTotalSize, t.byteLength - t.bytesFilled), i = t.bytesFilled + o, s = i - i % r; let a = o, l = !1; s > n && (a = s - t.bytesFilled, l = !0); const u = e._queue; for (; a > 0;) { const r = u.peek(), n = Math.min(a, r.byteLength), o = t.byteOffset + t.bytesFilled; ct(t.buffer, o, r.buffer, r.byteOffset, n), r.byteLength === n ? u.shift() : (r.byteOffset += n, r.byteLength -= n), e._queueTotalSize -= n, At(0, n, t), a -= n } return l } function At(e, t, r) { r.bytesFilled += t } function It(e) { 0 === e._queueTotalSize && e._closeRequested ? (Lt(e), on(e._controlledReadableByteStream)) : _t(e) } function Ot(e) { null !== e._byobRequest && (e._byobRequest._associatedReadableByteStreamController = void 0, e._byobRequest._view = null, e._byobRequest = null) } function Pt(e) { for (; e._pendingPullIntos.length > 0;) { if (0 === e._queueTotalSize) return; const t = e._pendingPullIntos.peek(); kt(e, t) && (Ct(e), vt(e._controlledReadableByteStream, t)) } } function Bt(e, t) { const r = e._pendingPullIntos.peek(); Ot(e), "closed" === e._controlledReadableByteStream._state ? function (e, t) { "none" === t.readerType && Ct(e); const r = e._controlledReadableByteStream; if (Nt(r)) for (; jt(r) > 0;)vt(r, Ct(e)) }(e, r) : function (e, t, r) { if (At(0, t, r), "none" === r.readerType) return Tt(e, r), void Pt(e); if (r.bytesFilled < r.elementSize) return; Ct(e); const n = r.bytesFilled % r.elementSize; if (n > 0) { const t = r.byteOffset + r.bytesFilled; Rt(e, r.buffer, t - n, n) } r.bytesFilled -= n, vt(e._controlledReadableByteStream, r), Pt(e) }(e, t, r), _t(e) } function Ct(e) { return e._pendingPullIntos.shift() } function Lt(e) { e._pullAlgorithm = void 0, e._cancelAlgorithm = void 0 } function qt(e, t) { const r = e._controlledReadableByteStream; "readable" === r._state && (mt(e), pt(e), Lt(e), sn(r, t)) } function zt(e, t) { const r = e._queue.shift(); e._queueTotalSize -= r.byteLength, It(e); const n = new Uint8Array(r.buffer, r.byteOffset, r.byteLength); t._chunkSteps(n) } function xt(e) { const t = e._controlledReadableByteStream._state; return "errored" === t ? null : "closed" === t ? 0 : e._strategyHWM - e._queueTotalSize } function Wt(e) { return new TypeError(`ReadableStreamBYOBRequest.prototype.${e} can only be used on a ReadableStreamBYOBRequest`) } function Ut(e) { return new TypeError(`ReadableByteStreamController.prototype.${e} can only be used on a ReadableByteStreamController`) } function Ft(e, t) { e._reader._readIntoRequests.push(t) } function jt(e) { return e._reader._readIntoRequests.length } function Nt(e) { const t = e._reader; return void 0 !== t && !!Mt(t) } Object.defineProperties(yt.prototype, { close: { enumerable: !0 }, enqueue: { enumerable: !0 }, error: { enumerable: !0 }, byobRequest: { enumerable: !0 }, desiredSize: { enumerable: !0 } }), ae(yt.prototype.close, "close"), ae(yt.prototype.enqueue, "enqueue"), ae(yt.prototype.error, "error"), "symbol" == typeof ne.toStringTag && Object.defineProperty(yt.prototype, ne.toStringTag, { value: "ReadableByteStreamController", configurable: !0 }); class $t { constructor(e) { if (Me(e, 1, "ReadableStreamBYOBReader"), Ge(e, "First parameter"), rn(e)) throw new TypeError("This stream has already been locked for exclusive reading by another reader"); if (!gt(e._readableStreamController)) throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source"); Pe(this, e), this._readIntoRequests = new Re } get closed() { return Mt(this) ? this._closedPromise : pe(Vt("closed")) } cancel(e) { return Mt(this) ? void 0 === this._ownerReadableStream ? pe(Le("cancel")) : Be(this, e) : pe(Vt("cancel")) } read(e) { if (!Mt(this)) return pe(Vt("read")); if (!ArrayBuffer.isView(e)) return pe(new TypeError("view must be an array buffer view")); if (0 === e.byteLength) return pe(new TypeError("view must have non-zero byteLength")); if (0 === e.buffer.byteLength) return pe(new TypeError("view's buffer must have non-zero byteLength")); if (e.buffer, void 0 === this._ownerReadableStream) return pe(Le("read from")); let t, r; const n = he(((e, n) => { t = e, r = n })); return function (e, t, r) { const n = e._ownerReadableStream; n._disturbed = !0, "errored" === n._state ? r._errorSteps(n._storedError) : function (e, t, r) { const n = e._controlledReadableByteStream; let o = 1; t.constructor !== DataView && (o = t.constructor.BYTES_PER_ELEMENT); const i = t.constructor, s = t.buffer, a = { buffer: s, bufferByteLength: s.byteLength, byteOffset: t.byteOffset, byteLength: t.byteLength, bytesFilled: 0, elementSize: o, viewConstructor: i, readerType: "byob" }; if (e._pendingPullIntos.length > 0) return e._pendingPullIntos.push(a), void Ft(n, r); if ("closed" !== n._state) { if (e._queueTotalSize > 0) { if (kt(e, a)) { const t = St(a); return It(e), void r._chunkSteps(t) } if (e._closeRequested) { const t = new TypeError("Insufficient bytes to fill elements in the given buffer"); return qt(e, t), void r._errorSteps(t) } } e._pendingPullIntos.push(a), Ft(n, r), _t(e) } else { const e = new i(a.buffer, a.byteOffset, 0); r._closeSteps(e) } }(n._readableStreamController, t, r) }(this, e, { _chunkSteps: e => t({ value: e, done: !1 }), _closeSteps: e => t({ value: e, done: !0 }), _errorSteps: e => r(e) }), n } releaseLock() { if (!Mt(this)) throw Vt("releaseLock"); void 0 !== this._ownerReadableStream && function (e) { Ce(e), Dt(e, new TypeError("Reader was released")) }(this) } } function Mt(e) { return !!ie(e) && !!Object.prototype.hasOwnProperty.call(e, "_readIntoRequests") && e instanceof $t } function Dt(e, t) { const r = e._readIntoRequests; e._readIntoRequests = new Re, r.forEach((e => { e._errorSteps(t) })) } function Vt(e) { return new TypeError(`ReadableStreamBYOBReader.prototype.${e} can only be used on a ReadableStreamBYOBReader`) } function Ht(e, t) { const { highWaterMark: r } = e; if (void 0 === r) return t; if (ut(r) || r < 0) throw new RangeError("Invalid highWaterMark"); return r } function Kt(e) { const { size: t } = e; return t || (() => 1) } function Yt(e, t) { je(e, t); const r = null == e ? void 0 : e.highWaterMark, n = null == e ? void 0 : e.size; return { highWaterMark: void 0 === r ? void 0 : Ve(r), size: void 0 === n ? void 0 : Qt(n, `${t} has member 'size' that`) } } function Qt(e, t) { return Ne(e, t), t => Ve(e(t)) } function Gt(e, t, r) { return Ne(e, r), r => Ee(e, t, [r]) } function Xt(e, t, r) { return Ne(e, r), () => Ee(e, t, []) } function Jt(e, t, r) { return Ne(e, r), r => Se(e, t, [r]) } function Zt(e, t, r) { return Ne(e, r), (r, n) => Ee(e, t, [r, n]) } Object.defineProperties($t.prototype, { cancel: { enumerable: !0 }, read: { enumerable: !0 }, releaseLock: { enumerable: !0 }, closed: { enumerable: !0 } }), ae($t.prototype.cancel, "cancel"), ae($t.prototype.read, "read"), ae($t.prototype.releaseLock, "releaseLock"), "symbol" == typeof ne.toStringTag && Object.defineProperty($t.prototype, ne.toStringTag, { value: "ReadableStreamBYOBReader", configurable: !0 }); const er = "function" == typeof AbortController; class tr { constructor(e = {}, t = {}) { void 0 === e ? e = null : $e(e, "First parameter"); const r = Yt(t, "Second parameter"), n = function (e, t) { je(e, t); const r = null == e ? void 0 : e.abort, n = null == e ? void 0 : e.close, o = null == e ? void 0 : e.start, i = null == e ? void 0 : e.type, s = null == e ? void 0 : e.write; return { abort: void 0 === r ? void 0 : Gt(r, e, `${t} has member 'abort' that`), close: void 0 === n ? void 0 : Xt(n, e, `${t} has member 'close' that`), start: void 0 === o ? void 0 : Jt(o, e, `${t} has member 'start' that`), write: void 0 === s ? void 0 : Zt(s, e, `${t} has member 'write' that`), type: i } }(e, "First parameter"); var o; if ((o = this)._state = "writable", o._storedError = void 0, o._writer = void 0, o._writableStreamController = void 0, o._writeRequests = new Re, o._inFlightWriteRequest = void 0, o._closeRequest = void 0, o._inFlightCloseRequest = void 0, o._pendingAbortRequest = void 0, o._backpressure = !1, void 0 !== n.type) throw new RangeError("Invalid type is specified"); const i = Kt(r); !function (e, t, r, n) { const o = Object.create(yr.prototype); let i, s, a, l; i = void 0 !== t.start ? () => t.start(o) : () => { }, s = void 0 !== t.write ? e => t.write(e, o) : () => fe(void 0), a = void 0 !== t.close ? () => t.close() : () => fe(void 0), l = void 0 !== t.abort ? e => t.abort(e) : () => fe(void 0), function (e, t, r, n, o, i, s, a) { t._controlledWritableStream = e, e._writableStreamController = t, t._queue = void 0, t._queueTotalSize = void 0, pt(t), t._abortReason = void 0, t._abortController = function () { if (er) return new AbortController }(), t._started = !1, t._strategySizeAlgorithm = a, t._strategyHWM = s, t._writeAlgorithm = n, t._closeAlgorithm = o, t._abortAlgorithm = i; const l = Sr(t); dr(e, l), ye(fe(r()), (() => (t._started = !0, mr(t), null)), (r => (t._started = !0, sr(e, r), null))) }(e, o, i, s, a, l, r, n) }(this, n, Ht(r, 1), i) } get locked() { if (!rr(this)) throw Rr("locked"); return nr(this) } abort(e) { return rr(this) ? nr(this) ? pe(new TypeError("Cannot abort a stream that already has a writer")) : or(this, e) : pe(Rr("abort")) } close() { return rr(this) ? nr(this) ? pe(new TypeError("Cannot close a stream that already has a writer")) : ur(this) ? pe(new TypeError("Cannot close an already-closing stream")) : ir(this) : pe(Rr("close")) } getWriter() { if (!rr(this)) throw Rr("getWriter"); return new hr(this) } } function rr(e) { return !!ie(e) && !!Object.prototype.hasOwnProperty.call(e, "_writableStreamController") && e instanceof tr } function nr(e) { return void 0 !== e._writer } function or(e, t) { var r; if ("closed" === e._state || "errored" === e._state) return fe(void 0); e._writableStreamController._abortReason = t, null === (r = e._writableStreamController._abortController) || void 0 === r || r.abort(t); const n = e._state; if ("closed" === n || "errored" === n) return fe(void 0); if (void 0 !== e._pendingAbortRequest) return e._pendingAbortRequest._promise; let o = !1; "erroring" === n && (o = !0, t = void 0); const i = he(((r, n) => { e._pendingAbortRequest = { _promise: void 0, _resolve: r, _reject: n, _reason: t, _wasAlreadyErroring: o } })); return e._pendingAbortRequest._promise = i, o || ar(e, t), i } function ir(e) { const t = e._state; if ("closed" === t || "errored" === t) return pe(new TypeError(`The stream (in ${t} state) is not in the writable state and cannot be closed`)); const r = he(((t, r) => { const n = { _resolve: t, _reject: r }; e._closeRequest = n })), n = e._writer; var o; return void 0 !== n && e._backpressure && "writable" === t && xr(n), ft(o = e._writableStreamController, br, 0), mr(o), r } function sr(e, t) { "writable" !== e._state ? lr(e) : ar(e, t) } function ar(e, t) { const r = e._writableStreamController; e._state = "erroring", e._storedError = t; const n = e._writer; void 0 !== n && pr(n, t), !function (e) { return void 0 !== e._inFlightWriteRequest || void 0 !== e._inFlightCloseRequest }(e) && r._started && lr(e) } function lr(e) { e._state = "errored", e._writableStreamController[ke](); const t = e._storedError; if (e._writeRequests.forEach((e => { e._reject(t) })), e._writeRequests = new Re, void 0 === e._pendingAbortRequest) return void cr(e); const r = e._pendingAbortRequest; if (e._pendingAbortRequest = void 0, r._wasAlreadyErroring) return r._reject(t), void cr(e); ye(e._writableStreamController[Te](r._reason), (() => (r._resolve(), cr(e), null)), (t => (r._reject(t), cr(e), null))) } function ur(e) { return void 0 !== e._closeRequest || void 0 !== e._inFlightCloseRequest } function cr(e) { void 0 !== e._closeRequest && (e._closeRequest._reject(e._storedError), e._closeRequest = void 0); const t = e._writer; void 0 !== t && Pr(t, e._storedError) } function dr(e, t) { const r = e._writer; void 0 !== r && t !== e._backpressure && (t ? function (e) { Cr(e) }(r) : xr(r)), e._backpressure = t } Object.defineProperties(tr.prototype, { abort: { enumerable: !0 }, close: { enumerable: !0 }, getWriter: { enumerable: !0 }, locked: { enumerable: !0 } }), ae(tr.prototype.abort, "abort"), ae(tr.prototype.close, "close"), ae(tr.prototype.getWriter, "getWriter"), "symbol" == typeof ne.toStringTag && Object.defineProperty(tr.prototype, ne.toStringTag, { value: "WritableStream", configurable: !0 }); class hr { constructor(e) { if (Me(e, 1, "WritableStreamDefaultWriter"), function (e, t) { if (!rr(e)) throw new TypeError("First parameter is not a WritableStream.") }(e), nr(e)) throw new TypeError("This stream has already been locked for exclusive writing by another writer"); this._ownerWritableStream = e, e._writer = this; const t = e._state; if ("writable" === t) !ur(e) && e._backpressure ? Cr(this) : qr(this), Ir(this); else if ("erroring" === t) Lr(this, e._storedError), Ir(this); else if ("closed" === t) qr(this), Ir(this), Br(this); else { const t = e._storedError; Lr(this, t), Or(this, t) } } get closed() { return fr(this) ? this._closedPromise : pe(kr("closed")) } get desiredSize() { if (!fr(this)) throw kr("desiredSize"); if (void 0 === this._ownerWritableStream) throw Ar("desiredSize"); return function (e) { const t = e._ownerWritableStream, r = t._state; return "errored" === r || "erroring" === r ? null : "closed" === r ? 0 : _r(t._writableStreamController) }(this) } get ready() { return fr(this) ? this._readyPromise : pe(kr("ready")) } abort(e) { return fr(this) ? void 0 === this._ownerWritableStream ? pe(Ar("abort")) : function (e, t) { return or(e._ownerWritableStream, t) }(this, e) : pe(kr("abort")) } close() { if (!fr(this)) return pe(kr("close")); const e = this._ownerWritableStream; return void 0 === e ? pe(Ar("close")) : ur(e) ? pe(new TypeError("Cannot close an already-closing stream")) : ir(this._ownerWritableStream) } releaseLock() { if (!fr(this)) throw kr("releaseLock"); void 0 !== this._ownerWritableStream && function (e) { const t = e._ownerWritableStream, r = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness"); pr(e, r), function (e, t) { "pending" === e._closedPromiseState ? Pr(e, t) : function (e, t) { Or(e, t) }(e, t) }(e, r), t._writer = void 0, e._ownerWritableStream = void 0 }(this) } write(e) { return fr(this) ? void 0 === this._ownerWritableStream ? pe(Ar("write to")) : function (e, t) { const r = e._ownerWritableStream, n = r._writableStreamController, o = function (e, t) { try { return e._strategySizeAlgorithm(t) } catch (t) { return vr(e, t), 1 } }(n, t); if (r !== e._ownerWritableStream) return pe(Ar("write to")); const i = r._state; if ("errored" === i) return pe(r._storedError); if (ur(r) || "closed" === i) return pe(new TypeError("The stream is closing or closed and cannot be written to")); if ("erroring" === i) return pe(r._storedError); const s = function (e) { return he(((t, r) => { const n = { _resolve: t, _reject: r }; e._writeRequests.push(n) })) }(r); return function (e, t, r) { try { ft(e, t, r) } catch (t) { return void vr(e, t) } const n = e._controlledWritableStream; ur(n) || "writable" !== n._state || dr(n, Sr(e)), mr(e) }(n, t, o), s }(this, e) : pe(kr("write")) } } function fr(e) { return !!ie(e) && !!Object.prototype.hasOwnProperty.call(e, "_ownerWritableStream") && e instanceof hr } function pr(e, t) { "pending" === e._readyPromiseState ? zr(e, t) : function (e, t) { Lr(e, t) }(e, t) } Object.defineProperties(hr.prototype, { abort: { enumerable: !0 }, close: { enumerable: !0 }, releaseLock: { enumerable: !0 }, write: { enumerable: !0 }, closed: { enumerable: !0 }, desiredSize: { enumerable: !0 }, ready: { enumerable: !0 } }), ae(hr.prototype.abort, "abort"), ae(hr.prototype.close, "close"), ae(hr.prototype.releaseLock, "releaseLock"), ae(hr.prototype.write, "write"), "symbol" == typeof ne.toStringTag && Object.defineProperty(hr.prototype, ne.toStringTag, { value: "WritableStreamDefaultWriter", configurable: !0 }); const br = {}; class yr { constructor() { throw new TypeError("Illegal constructor") } get abortReason() { if (!gr(this)) throw Tr("abortReason"); return this._abortReason } get signal() { if (!gr(this)) throw Tr("signal"); if (void 0 === this._abortController) throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported"); return this._abortController.signal } error(e) { if (!gr(this)) throw Tr("error"); "writable" === this._controlledWritableStream._state && Er(this, e) } [Te](e) { const t = this._abortAlgorithm(e); return wr(this), t } [ke]() { pt(this) } } function gr(e) { return !!ie(e) && !!Object.prototype.hasOwnProperty.call(e, "_controlledWritableStream") && e instanceof yr } function wr(e) { e._writeAlgorithm = void 0, e._closeAlgorithm = void 0, e._abortAlgorithm = void 0, e._strategySizeAlgorithm = void 0 } function _r(e) { return e._strategyHWM - e._queueTotalSize } function mr(e) { const t = e._controlledWritableStream; if (!e._started) return; if (void 0 !== t._inFlightWriteRequest) return; if ("erroring" === t._state) return void lr(t); if (0 === e._queue.length) return; const r = e._queue.peek().value; r === br ? function (e) { const t = e._controlledWritableStream; (function (e) { e._inFlightCloseRequest = e._closeRequest, e._closeRequest = void 0 })(t), ht(e); const r = e._closeAlgorithm(); wr(e), ye(r, (() => (function (e) { e._inFlightCloseRequest._resolve(void 0), e._inFlightCloseRequest = void 0, "erroring" === e._state && (e._storedError = void 0, void 0 !== e._pendingAbortRequest && (e._pendingAbortRequest._resolve(), e._pendingAbortRequest = void 0)), e._state = "closed"; const t = e._writer; void 0 !== t && Br(t) }(t), null)), (e => (function (e, t) { e._inFlightCloseRequest._reject(t), e._inFlightCloseRequest = void 0, void 0 !== e._pendingAbortRequest && (e._pendingAbortRequest._reject(t), e._pendingAbortRequest = void 0), sr(e, t) }(t, e), null))) }(e) : function (e, t) { const r = e._controlledWritableStream; !function (e) { e._inFlightWriteRequest = e._writeRequests.shift() }(r), ye(e._writeAlgorithm(t), (() => { !function (e) { e._inFlightWriteRequest._resolve(void 0), e._inFlightWriteRequest = void 0 }(r); const t = r._state; if (ht(e), !ur(r) && "writable" === t) { const t = Sr(e); dr(r, t) } return mr(e), null }), (t => ("writable" === r._state && wr(e), function (e, t) { e._inFlightWriteRequest._reject(t), e._inFlightWriteRequest = void 0, sr(e, t) }(r, t), null))) }(e, r) } function vr(e, t) { "writable" === e._controlledWritableStream._state && Er(e, t) } function Sr(e) { return _r(e) <= 0 } function Er(e, t) { const r = e._controlledWritableStream; wr(e), ar(r, t) } function Rr(e) { return new TypeError(`WritableStream.prototype.${e} can only be used on a WritableStream`) } function Tr(e) { return new TypeError(`WritableStreamDefaultController.prototype.${e} can only be used on a WritableStreamDefaultController`) } function kr(e) { return new TypeError(`WritableStreamDefaultWriter.prototype.${e} can only be used on a WritableStreamDefaultWriter`) } function Ar(e) { return new TypeError("Cannot " + e + " a stream using a released writer") } function Ir(e) { e._closedPromise = he(((t, r) => { e._closedPromise_resolve = t, e._closedPromise_reject = r, e._closedPromiseState = "pending" })) } function Or(e, t) { Ir(e), Pr(e, t) } function Pr(e, t) { void 0 !== e._closedPromise_reject && (me(e._closedPromise), e._closedPromise_reject(t), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0, e._closedPromiseState = "rejected") } function Br(e) { void 0 !== e._closedPromise_resolve && (e._closedPromise_resolve(void 0), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0, e._closedPromiseState = "resolved") } function Cr(e) { e._readyPromise = he(((t, r) => { e._readyPromise_resolve = t, e._readyPromise_reject = r })), e._readyPromiseState = "pending" } function Lr(e, t) { Cr(e), zr(e, t) } function qr(e) { Cr(e), xr(e) } function zr(e, t) { void 0 !== e._readyPromise_reject && (me(e._readyPromise), e._readyPromise_reject(t), e._readyPromise_resolve = void 0, e._readyPromise_reject = void 0, e._readyPromiseState = "rejected") } function xr(e) { void 0 !== e._readyPromise_resolve && (e._readyPromise_resolve(void 0), e._readyPromise_resolve = void 0, e._readyPromise_reject = void 0, e._readyPromiseState = "fulfilled") } Object.defineProperties(yr.prototype, { abortReason: { enumerable: !0 }, signal: { enumerable: !0 }, error: { enumerable: !0 } }), "symbol" == typeof ne.toStringTag && Object.defineProperty(yr.prototype, ne.toStringTag, { value: "WritableStreamDefaultController", configurable: !0 }); const Wr = "undefined" != typeof DOMException ? DOMException : void 0, Ur = function (e) { if ("function" != typeof e && "object" != typeof e) return !1; try { return new e, !0 } catch (e) { return !1 } }(Wr) ? Wr : function () { const e = function (e, t) { this.message = e || "", this.name = t || "Error", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor) }; return e.prototype = Object.create(Error.prototype), Object.defineProperty(e.prototype, "constructor", { value: e, writable: !0, configurable: !0 }), e }(); function Fr(e, t, r, n, o, i) { const s = e.getReader(), a = t.getWriter(); tn(e) && (e._disturbed = !0); let l, u, c, d = !1, h = !1, f = "readable", p = "writable", b = !1, y = !1; const g = he((e => { c = e })); let w = Promise.resolve(void 0); return he(((_, m) => { let v; function S() { if (d) return; const e = he(((e, t) => { !function r(n) { n ? e() : be(d ? fe(!0) : be(a.ready, (() => be(s.read(), (e => !!e.done || (w = a.write(e.value), me(w), !1))))), r, t) }(!1) })); me(e) } function E() { return f = "closed", r ? A() : k((() => (rr(t) && (b = ur(t), p = t._state), b || "closed" === p ? fe(void 0) : "erroring" === p || "errored" === p ? pe(u) : (b = !0, a.close()))), !1, void 0), null } function R(e) { return d || (f = "errored", l = e, n ? A(!0, e) : k((() => a.abort(e)), !0, e)), null } function T(e) { return h || (p = "errored", u = e, o ? A(!0, e) : k((() => s.cancel(e)), !0, e)), null } if (void 0 !== i && (v = () => { const e = void 0 !== i.reason ? i.reason : new Ur("Aborted", "AbortError"), t = []; n || t.push((() => "writable" === p ? a.abort(e) : fe(void 0))), o || t.push((() => "readable" === f ? s.cancel(e) : fe(void 0))), k((() => Promise.all(t.map((e => e())))), !0, e) }, i.aborted ? v() : i.addEventListener("abort", v)), tn(e) && (f = e._state, l = e._storedError), rr(t) && (p = t._state, u = t._storedError, b = ur(t)), tn(e) && rr(t) && (y = !0, c()), "errored" === f) R(l); else if ("erroring" === p || "errored" === p) T(u); else if ("closed" === f) E(); else if (b || "closed" === p) { const e = new TypeError("the destination writable stream closed before all data could be piped to it"); o ? A(!0, e) : k((() => s.cancel(e)), !0, e) } function k(e, t, r) { function n() { return "writable" !== p || b ? o() : ge(function () { let e; return fe(function t() { if (e !== w) return e = w, _e(w, t, t) }()) }(), o), null } function o() { return e ? ye(e(), (() => I(t, r)), (e => I(!0, e))) : I(t, r), null } d || (d = !0, y ? n() : ge(g, n)) } function A(e, t) { k(void 0, e, t) } function I(e, t) { return h = !0, a.releaseLock(), s.releaseLock(), void 0 !== i && i.removeEventListener("abort", v), e ? m(t) : _(void 0), null } d || (ye(s.closed, E, R), ye(a.closed, (function () { return h || (p = "closed"), null }), T)), y ? S() : ve((() => { y = !0, c(), S() })) })) } class jr { constructor() { throw new TypeError("Illegal constructor") } get desiredSize() { if (!Nr(this)) throw Kr("desiredSize"); return Vr(this) } close() { if (!Nr(this)) throw Kr("close"); if (!Hr(this)) throw new TypeError("The stream is not in a state that permits close"); !function (e) { if (!Hr(e)) return; const t = e._controlledReadableStream; e._closeRequested = !0, 0 === e._queue.length && (Mr(e), on(t)) }(this) } enqueue(e) { if (!Nr(this)) throw Kr("enqueue"); if (!Hr(this)) throw new TypeError("The stream is not in a state that permits enqueue"); return function (e, t) { if (!Hr(e)) return; const r = e._controlledReadableStream; if (rn(r) && Ze(r) > 0) Je(r, t, !1); else { let r; try { r = e._strategySizeAlgorithm(t) } catch (t) { throw Dr(e, t), t } try { ft(e, t, r) } catch (t) { throw Dr(e, t), t } } $r(e) }(this, e) } error(e) { if (!Nr(this)) throw Kr("error"); Dr(this, e) } [Ae](e) { pt(this); const t = this._cancelAlgorithm(e); return Mr(this), t } [Ie](e) { const t = this._controlledReadableStream; if (this._queue.length > 0) { const r = ht(this); this._closeRequested && 0 === this._queue.length ? (Mr(this), on(t)) : $r(this), e._chunkSteps(r) } else Xe(t, e), $r(this) } [Oe]() { } } function Nr(e) { return !!ie(e) && !!Object.prototype.hasOwnProperty.call(e, "_controlledReadableStream") && e instanceof jr } function $r(e) { const t = function (e) { const t = e._controlledReadableStream; return !!Hr(e) && !!e._started && (!!(rn(t) && Ze(t) > 0) || Vr(e) > 0) }(e); t && (e._pulling ? e._pullAgain = !0 : (e._pulling = !0, ye(e._pullAlgorithm(), (() => (e._pulling = !1, e._pullAgain && (e._pullAgain = !1, $r(e)), null)), (t => (Dr(e, t), null))))) } function Mr(e) { e._pullAlgorithm = void 0, e._cancelAlgorithm = void 0, e._strategySizeAlgorithm = void 0 } function Dr(e, t) { const r = e._controlledReadableStream; "readable" === r._state && (pt(e), Mr(e), sn(r, t)) } function Vr(e) { const t = e._controlledReadableStream._state; return "errored" === t ? null : "closed" === t ? 0 : e._strategyHWM - e._queueTotalSize } function Hr(e) { return !e._closeRequested && "readable" === e._controlledReadableStream._state } function Kr(e) { return new TypeError(`ReadableStreamDefaultController.prototype.${e} can only be used on a ReadableStreamDefaultController`) } function Yr(e, t, r) { return Ne(e, r), r => Ee(e, t, [r]) } function Qr(e, t, r) { return Ne(e, r), r => Ee(e, t, [r]) } function Gr(e, t, r) { return Ne(e, r), r => Se(e, t, [r]) } function Xr(e, t) { if ("bytes" != (e = `${e}`)) throw new TypeError(`${t} '${e}' is not a valid enumeration value for ReadableStreamType`); return e } function Jr(e, t) { if ("byob" != (e = `${e}`)) throw new TypeError(`${t} '${e}' is not a valid enumeration value for ReadableStreamReaderMode`); return e } function Zr(e, t) { je(e, t); const r = null == e ? void 0 : e.preventAbort, n = null == e ? void 0 : e.preventCancel, o = null == e ? void 0 : e.preventClose, i = null == e ? void 0 : e.signal; return void 0 !== i && function (e, t) { if (!function (e) { if ("object" != typeof e || null === e) return !1; try { return "boolean" == typeof e.aborted } catch (e) { return !1 } }(e)) throw new TypeError(`${t} is not an AbortSignal.`) }(i, `${t} has member 'signal' that`), { preventAbort: Boolean(r), preventCancel: Boolean(n), preventClose: Boolean(o), signal: i } } Object.defineProperties(jr.prototype, { close: { enumerable: !0 }, enqueue: { enumerable: !0 }, error: { enumerable: !0 }, desiredSize: { enumerable: !0 } }), ae(jr.prototype.close, "close"), ae(jr.prototype.enqueue, "enqueue"), ae(jr.prototype.error, "error"), "symbol" == typeof ne.toStringTag && Object.defineProperty(jr.prototype, ne.toStringTag, { value: "ReadableStreamDefaultController", configurable: !0 }); class en { constructor(e = {}, t = {}) { void 0 === e ? e = null : $e(e, "First parameter"); const r = Yt(t, "Second parameter"), n = function (e, t) { je(e, t); const r = e, n = null == r ? void 0 : r.autoAllocateChunkSize, o = null == r ? void 0 : r.cancel, i = null == r ? void 0 : r.pull, s = null == r ? void 0 : r.start, a = null == r ? void 0 : r.type; return { autoAllocateChunkSize: void 0 === n ? void 0 : Ke(n, `${t} has member 'autoAllocateChunkSize' that`), cancel: void 0 === o ? void 0 : Yr(o, r, `${t} has member 'cancel' that`), pull: void 0 === i ? void 0 : Qr(i, r, `${t} has member 'pull' that`), start: void 0 === s ? void 0 : Gr(s, r, `${t} has member 'start' that`), type: void 0 === a ? void 0 : Xr(a, `${t} has member 'type' that`) } }(e, "First parameter"); var o; if ((o = this)._state = "readable", o._reader = void 0, o._storedError = void 0, o._disturbed = !1, "bytes" === n.type) { if (void 0 !== r.size) throw new RangeError("The strategy for a byte stream cannot have a size function"); !function (e, t, r) { const n = Object.create(yt.prototype); let o, i, s; o = void 0 !== t.start ? () => t.start(n) : () => { }, i = void 0 !== t.pull ? () => t.pull(n) : () => fe(void 0), s = void 0 !== t.cancel ? e => t.cancel(e) : () => fe(void 0); const a = t.autoAllocateChunkSize; if (0 === a) throw new TypeError("autoAllocateChunkSize must be greater than 0"); !function (e, t, r, n, o, i, s) { t._controlledReadableByteStream = e, t._pullAgain = !1, t._pulling = !1, t._byobRequest = null, t._queue = t._queueTotalSize = void 0, pt(t), t._closeRequested = !1, t._started = !1, t._strategyHWM = i, t._pullAlgorithm = n, t._cancelAlgorithm = o, t._autoAllocateChunkSize = s, t._pendingPullIntos = new Re, e._readableStreamController = t, ye(fe(r()), (() => (t._started = !0, _t(t), null)), (e => (qt(t, e), null))) }(e, n, o, i, s, r, a) }(this, n, Ht(r, 0)) } else { const e = Kt(r); !function (e, t, r, n) { const o = Object.create(jr.prototype); let i, s, a; i = void 0 !== t.start ? () => t.start(o) : () => { }, s = void 0 !== t.pull ? () => t.pull(o) : () => fe(void 0), a = void 0 !== t.cancel ? e => t.cancel(e) : () => fe(void 0), function (e, t, r, n, o, i, s) { t._controlledReadableStream = e, t._queue = void 0, t._queueTotalSize = void 0, pt(t), t._started = !1, t._closeRequested = !1, t._pullAgain = !1, t._pulling = !1, t._strategySizeAlgorithm = s, t._strategyHWM = i, t._pullAlgorithm = n, t._cancelAlgorithm = o, e._readableStreamController = t, ye(fe(r()), (() => (t._started = !0, $r(t), null)), (e => (Dr(t, e), null))) }(e, o, i, s, a, r, n) }(this, n, Ht(r, 1), e) } } get locked() { if (!tn(this)) throw an("locked"); return rn(this) } cancel(e) { return tn(this) ? rn(this) ? pe(new TypeError("Cannot cancel a stream that already has a reader")) : nn(this, e) : pe(an("cancel")) } getReader(e) { if (!tn(this)) throw an("getReader"); return void 0 === function (e, t) { je(e, t); const r = null == e ? void 0 : e.mode; return { mode: void 0 === r ? void 0 : Jr(r, `${t} has member 'mode' that`) } }(e, "First parameter").mode ? new tt(this) : function (e) { return new $t(e) }(this) } pipeThrough(e, t = {}) { if (!Ye(this)) throw an("pipeThrough"); Me(e, 1, "pipeThrough"); const r = function (e, t) { je(e, t); const r = null == e ? void 0 : e.readable; De(r, "readable", "ReadableWritablePair"), function (e, t) { if (!Ye(e)) throw new TypeError(`${t} is not a ReadableStream.`) }(r, `${t} has member 'readable' that`); const n = null == e ? void 0 : e.writable; return De(n, "writable", "ReadableWritablePair"), function (e, t) { if (!Qe(e)) throw new TypeError(`${t} is not a WritableStream.`) }(n, `${t} has member 'writable' that`), { readable: r, writable: n } }(e, "First parameter"), n = Zr(t, "Second parameter"); if (this.locked) throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream"); if (r.writable.locked) throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream"); return me(Fr(this, r.writable, n.preventClose, n.preventAbort, n.preventCancel, n.signal)), r.readable } pipeTo(e, t = {}) { if (!Ye(this)) return pe(an("pipeTo")); if (void 0 === e) return pe("Parameter 1 is required in 'pipeTo'."); if (!Qe(e)) return pe(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream")); let r; try { r = Zr(t, "Second parameter") } catch (e) { return pe(e) } return this.locked ? pe(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")) : e.locked ? pe(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")) : Fr(this, e, r.preventClose, r.preventAbort, r.preventCancel, r.signal) } tee() { if (!Ye(this)) throw an("tee"); if (this.locked) throw new TypeError("Cannot tee a stream that already has a reader"); return function (e, t) { return function (e) { try { return e.getReader({ mode: "byob" }).releaseLock(), !0 } catch (e) { return !1 } }(e) ? function (e) { let t, r, n, o, i, s = e.getReader(), a = !1, l = !1, u = !1, c = !1, d = !1, h = !1; const f = he((e => { i = e })); function p(e) { we(e.closed, (t => (e !== s || (n.error(t), o.error(t), d && h || i(void 0)), null))) } function b() { a && (s.releaseLock(), s = e.getReader(), p(s), a = !1), ye(s.read(), (e => { var t, r; if (u = !1, c = !1, e.done) return d || n.close(), h || o.close(), null === (t = n.byobRequest) || void 0 === t || t.respond(0), null === (r = o.byobRequest) || void 0 === r || r.respond(0), d && h || i(void 0), null; const a = e.value, f = a; let p = a; if (!d && !h) try { p = dt(a) } catch (e) { return n.error(e), o.error(e), i(s.cancel(e)), null } return d || n.enqueue(f), h || o.enqueue(p), l = !1, u ? g() : c && w(), null }), (() => (l = !1, null))) } function y(t, r) { a || (s.releaseLock(), s = e.getReader({ mode: "byob" }), p(s), a = !0); const f = r ? o : n, b = r ? n : o; ye(s.read(t), (e => { var t; u = !1, c = !1; const n = r ? h : d, o = r ? d : h; if (e.done) { n || f.close(), o || b.close(); const r = e.value; return void 0 !== r && (n || f.byobRequest.respondWithNewView(r), o || null === (t = b.byobRequest) || void 0 === t || t.respond(0)), n && o || i(void 0), null } const a = e.value; if (o) n || f.byobRequest.respondWithNewView(a); else { let t; try { t = dt(a) } catch (e) { return f.error(e), b.error(e), i(s.cancel(e)), null } n || f.byobRequest.respondWithNewView(a), b.enqueue(t) } return l = !1, u ? g() : c && w(), null }), (() => (l = !1, null))) } function g() { if (l) return u = !0, fe(void 0); l = !0; const e = n.byobRequest; return null === e ? b() : y(e.view, !1), fe(void 0) } function w() { if (l) return c = !0, fe(void 0); l = !0; const e = o.byobRequest; return null === e ? b() : y(e.view, !0), fe(void 0) } const _ = new en({ type: "bytes", start(e) { n = e }, pull: g, cancel: function (e) { if (d = !0, t = e, h) { const e = [t, r], n = s.cancel(e); i(n) } return f } }), m = new en({ type: "bytes", start(e) { o = e }, pull: w, cancel: function (e) { if (h = !0, r = e, d) { const e = [t, r], n = s.cancel(e); i(n) } return f } }); return p(s), [_, m] }(e) : function (e, t) { const r = e.getReader(); let n, o, i, s, a, l = !1, u = !1, c = !1, d = !1; const h = he((e => { a = e })); function f() { return l ? (u = !0, fe(void 0)) : (l = !0, ye(r.read(), (e => { if (u = !1, e.done) return c || i.close(), d || s.close(), c && d || a(void 0), null; const t = e.value, r = t, n = t; return c || i.enqueue(r), d || s.enqueue(n), l = !1, u && f(), null }), (() => (l = !1, null))), fe(void 0)) } const p = new en({ start(e) { i = e }, pull: f, cancel: function (e) { if (c = !0, n = e, d) { const e = [n, o], t = r.cancel(e); a(t) } return h } }), b = new en({ start(e) { s = e }, pull: f, cancel: function (e) { if (d = !0, o = e, c) { const e = [n, o], t = r.cancel(e); a(t) } return h } }); return we(r.closed, (e => (i.error(e), s.error(e), c && d || a(void 0), null))), [p, b] }(e) }(this) } values(e) { if (!Ye(this)) throw an("values"); return function (e, t) { const r = e.getReader(), n = new it(r, t), o = Object.create(st); return o._asyncIteratorImpl = n, o }(this, function (e, t) { je(e, "First parameter"); const r = null == e ? void 0 : e.preventCancel; return { preventCancel: Boolean(r) } }(e).preventCancel) } } function tn(e) { return !!ie(e) && !!Object.prototype.hasOwnProperty.call(e, "_readableStreamController") && e instanceof en } function rn(e) { return void 0 !== e._reader } function nn(e, t) { if (e._disturbed = !0, "closed" === e._state) return fe(void 0); if ("errored" === e._state) return pe(e._storedError); on(e); const r = e._reader; if (void 0 !== r && Mt(r)) { const e = r._readIntoRequests; r._readIntoRequests = new Re, e.forEach((e => { e._closeSteps(void 0) })) } return _e(e._readableStreamController[Ae](t), oe) } function on(e) { e._state = "closed"; const t = e._reader; if (void 0 !== t && (We(t), rt(t))) { const e = t._readRequests; t._readRequests = new Re, e.forEach((e => { e._closeSteps() })) } } function sn(e, t) { e._state = "errored", e._storedError = t; const r = e._reader; void 0 !== r && (xe(r, t), rt(r) ? nt(r, t) : Dt(r, t)) } function an(e) { return new TypeError(`ReadableStream.prototype.${e} can only be used on a ReadableStream`) } function ln(e, t) { je(e, t); const r = null == e ? void 0 : e.highWaterMark; return De(r, "highWaterMark", "QueuingStrategyInit"), { highWaterMark: Ve(r) } } Object.defineProperties(en.prototype, { cancel: { enumerable: !0 }, getReader: { enumerable: !0 }, pipeThrough: { enumerable: !0 }, pipeTo: { enumerable: !0 }, tee: { enumerable: !0 }, values: { enumerable: !0 }, locked: { enumerable: !0 } }), ae(en.prototype.cancel, "cancel"), ae(en.prototype.getReader, "getReader"), ae(en.prototype.pipeThrough, "pipeThrough"), ae(en.prototype.pipeTo, "pipeTo"), ae(en.prototype.tee, "tee"), ae(en.prototype.values, "values"), "symbol" == typeof ne.toStringTag && Object.defineProperty(en.prototype, ne.toStringTag, { value: "ReadableStream", configurable: !0 }), "symbol" == typeof ne.asyncIterator && Object.defineProperty(en.prototype, ne.asyncIterator, { value: en.prototype.values, writable: !0, configurable: !0 }); const un = e => e.byteLength; ae(un, "size"); class cn { constructor(e) { Me(e, 1, "ByteLengthQueuingStrategy"), e = ln(e, "First parameter"), this._byteLengthQueuingStrategyHighWaterMark = e.highWaterMark } get highWaterMark() { if (!hn(this)) throw dn("highWaterMark"); return this._byteLengthQueuingStrategyHighWaterMark } get size() { if (!hn(this)) throw dn("size"); return un } } function dn(e) { return new TypeError(`ByteLengthQueuingStrategy.prototype.${e} can only be used on a ByteLengthQueuingStrategy`) } function hn(e) { return !!ie(e) && !!Object.prototype.hasOwnProperty.call(e, "_byteLengthQueuingStrategyHighWaterMark") && e instanceof cn } Object.defineProperties(cn.prototype, { highWaterMark: { enumerable: !0 }, size: { enumerable: !0 } }), "symbol" == typeof ne.toStringTag && Object.defineProperty(cn.prototype, ne.toStringTag, { value: "ByteLengthQueuingStrategy", configurable: !0 }); const fn = () => 1; ae(fn, "size"); class pn { constructor(e) { Me(e, 1, "CountQueuingStrategy"), e = ln(e, "First parameter"), this._countQueuingStrategyHighWaterMark = e.highWaterMark } get highWaterMark() { if (!yn(this)) throw bn("highWaterMark"); return this._countQueuingStrategyHighWaterMark } get size() { if (!yn(this)) throw bn("size"); return fn } } function bn(e) { return new TypeError(`CountQueuingStrategy.prototype.${e} can only be used on a CountQueuingStrategy`) } function yn(e) { return !!ie(e) && !!Object.prototype.hasOwnProperty.call(e, "_countQueuingStrategyHighWaterMark") && e instanceof pn } function gn(e, t, r) { return Ne(e, r), r => Ee(e, t, [r]) } function wn(e, t, r) { return Ne(e, r), r => Se(e, t, [r]) } function _n(e, t, r) { return Ne(e, r), (r, n) => Ee(e, t, [r, n]) } Object.defineProperties(pn.prototype, { highWaterMark: { enumerable: !0 }, size: { enumerable: !0 } }), "symbol" == typeof ne.toStringTag && Object.defineProperty(pn.prototype, ne.toStringTag, { value: "CountQueuingStrategy", configurable: !0 }); class mn { constructor(e = {}, t = {}, r = {}) { void 0 === e && (e = null); const n = Yt(t, "Second parameter"), o = Yt(r, "Third parameter"), i = function (e, t) { je(e, t); const r = null == e ? void 0 : e.flush, n = null == e ? void 0 : e.readableType, o = null == e ? void 0 : e.start, i = null == e ? void 0 : e.transform, s = null == e ? void 0 : e.writableType; return { flush: void 0 === r ? void 0 : gn(r, e, `${t} has member 'flush' that`), readableType: n, start: void 0 === o ? void 0 : wn(o, e, `${t} has member 'start' that`), transform: void 0 === i ? void 0 : _n(i, e, `${t} has member 'transform' that`), writableType: s } }(e, "First parameter"); if (void 0 !== i.readableType) throw new RangeError("Invalid readableType specified"); if (void 0 !== i.writableType) throw new RangeError("Invalid writableType specified"); const s = Ht(o, 0), a = Kt(o), l = Ht(n, 1), u = Kt(n); let c; !function (e, t, r, n, o, i) { function s() { return t } e._writableState = "writable", e._writableStoredError = void 0, e._writableHasInFlightOperation = !1, e._writableStarted = !1, e._writable = function (e, t, r, n, o, i, s) { return new tr({ start(r) { e._writableController = r; try { const t = r.signal; void 0 !== t && t.addEventListener("abort", (() => { "writable" === e._writableState && (e._writableState = "erroring", t.reason && (e._writableStoredError = t.reason)) })) } catch (e) { } return _e(t(), (() => (e._writableStarted = !0, Fn(e), null)), (t => { throw e._writableStarted = !0, xn(e, t), t })) }, write: t => (function (e) { e._writableHasInFlightOperation = !0 }(e), _e(r(t), (() => (function (e) { e._writableHasInFlightOperation = !1 }(e), Fn(e), null)), (t => { throw function (e, t) { e._writableHasInFlightOperation = !1, xn(e, t) }(e, t), t }))), close: () => (function (e) { e._writableHasInFlightOperation = !0 }(e), _e(n(), (() => (function (e) { e._writableHasInFlightOperation = !1, "erroring" === e._writableState && (e._writableStoredError = void 0), e._writableState = "closed" }(e), null)), (t => { throw function (e, t) { e._writableHasInFlightOperation = !1, e._writableState, xn(e, t) }(e, t), t }))), abort: t => (e._writableState = "errored", e._writableStoredError = t, o(t)) }, { highWaterMark: i, size: s }) }(e, s, (function (t) { return function (e, t) { const r = e._transformStreamController; return e._backpressure ? _e(e._backpressureChangePromise, (() => { if ("erroring" === (rr(e._writable) ? e._writable._state : e._writableState)) throw rr(e._writable) ? e._writable._storedError : e._writableStoredError; return On(r, t) })) : On(r, t) }(e, t) }), (function () { return function (e) { const t = e._transformStreamController, r = t._flushAlgorithm(); return An(t), _e(r, (() => { if ("errored" === e._readableState) throw e._readableStoredError; Cn(e) && Ln(e) }), (t => { throw Sn(e, t), e._readableStoredError })) }(e) }), (function (t) { return function (e, t) { return Sn(e, t), fe(void 0) }(e, t) }), r, n), e._readableState = "readable", e._readableStoredError = void 0, e._readableCloseRequested = !1, e._readablePulling = !1, e._readable = function (e, t, r, n, o, i) { return new en({ start: r => (e._readableController = r, t().catch((t => { qn(e, t) }))), pull: () => (e._readablePulling = !0, r().catch((t => { qn(e, t) }))), cancel: t => (e._readableState = "closed", n(t)) }, { highWaterMark: o, size: i }) }(e, s, (function () { return function (e) { return Rn(e, !1), e._backpressureChangePromise }(e) }), (function (t) { return En(e, t), fe(void 0) }), o, i), e._backpressure = void 0, e._backpressureChangePromise = void 0, e._backpressureChangePromise_resolve = void 0, Rn(e, !0), e._transformStreamController = void 0 }(this, he((e => { c = e })), l, u, s, a), function (e, t) { const r = Object.create(Tn.prototype); let n, o; n = void 0 !== t.transform ? e => t.transform(e, r) : e => { try { return In(r, e), fe(void 0) } catch (e) { return pe(e) } }, o = void 0 !== t.flush ? () => t.flush(r) : () => fe(void 0), function (e, t, r, n) { t._controlledTransformStream = e, e._transformStreamController = t, t._transformAlgorithm = r, t._flushAlgorithm = n }(e, r, n, o) }(this, i), void 0 !== i.start ? c(i.start(this._transformStreamController)) : c(void 0) } get readable() { if (!vn(this)) throw Bn("readable"); return this._readable } get writable() { if (!vn(this)) throw Bn("writable"); return this._writable } } function vn(e) { return !!ie(e) && !!Object.prototype.hasOwnProperty.call(e, "_transformStreamController") && e instanceof mn } function Sn(e, t) { qn(e, t), En(e, t) } function En(e, t) { An(e._transformStreamController), function (e, t) { e._writableController.error(t), "writable" === e._writableState && Wn(e, t) }(e, t), e._backpressure && Rn(e, !1) } function Rn(e, t) { void 0 !== e._backpressureChangePromise && e._backpressureChangePromise_resolve(), e._backpressureChangePromise = he((t => { e._backpressureChangePromise_resolve = t })), e._backpressure = t } Object.defineProperties(mn.prototype, { readable: { enumerable: !0 }, writable: { enumerable: !0 } }), "symbol" == typeof ne.toStringTag && Object.defineProperty(mn.prototype, ne.toStringTag, { value: "TransformStream", configurable: !0 }); class Tn { constructor() { throw new TypeError("Illegal constructor") } get desiredSize() { if (!kn(this)) throw Pn("desiredSize"); return zn(this._controlledTransformStream) } enqueue(e) { if (!kn(this)) throw Pn("enqueue"); In(this, e) } error(e) { if (!kn(this)) throw Pn("error"); var t; t = e, Sn(this._controlledTransformStream, t) } terminate() { if (!kn(this)) throw Pn("terminate"); !function (e) { const t = e._controlledTransformStream; Cn(t) && Ln(t), En(t, new TypeError("TransformStream terminated")) }(this) } } function kn(e) { return !!ie(e) && !!Object.prototype.hasOwnProperty.call(e, "_controlledTransformStream") && e instanceof Tn } function An(e) { e._transformAlgorithm = void 0, e._flushAlgorithm = void 0 } function In(e, t) { const r = e._controlledTransformStream; if (!Cn(r)) throw new TypeError("Readable side is not in a state that permits enqueue"); try { !function (e, t) { e._readablePulling = !1; try { e._readableController.enqueue(t) } catch (t) { throw qn(e, t), t } }(r, t) } catch (e) { throw En(r, e), r._readableStoredError } const n = function (e) { return !function (e) { return !!Cn(e) && (!!e._readablePulling || zn(e) > 0) }(e) }(r); n !== r._backpressure && Rn(r, !0) } function On(e, t) { return _e(e._transformAlgorithm(t), void 0, (t => { throw Sn(e._controlledTransformStream, t), t })) } function Pn(e) { return new TypeError(`TransformStreamDefaultController.prototype.${e} can only be used on a TransformStreamDefaultController`) } function Bn(e) { return new TypeError(`TransformStream.prototype.${e} can only be used on a TransformStream`) } function Cn(e) { return !e._readableCloseRequested && "readable" === e._readableState } function Ln(e) { e._readableState = "closed", e._readableCloseRequested = !0, e._readableController.close() } function qn(e, t) { "readable" === e._readableState && (e._readableState = "errored", e._readableStoredError = t), e._readableController.error(t) } function zn(e) { return e._readableController.desiredSize } function xn(e, t) { "writable" !== e._writableState ? Un(e) : Wn(e, t) } function Wn(e, t) { e._writableState = "erroring", e._writableStoredError = t, !function (e) { return e._writableHasInFlightOperation }(e) && e._writableStarted && Un(e) } function Un(e) { e._writableState = "errored" } function Fn(e) { "erroring" === e._writableState && Un(e) } let jn; Object.defineProperties(Tn.prototype, { enqueue: { enumerable: !0 }, error: { enumerable: !0 }, terminate: { enumerable: !0 }, desiredSize: { enumerable: !0 } }), ae(Tn.prototype.enqueue, "enqueue"), ae(Tn.prototype.error, "error"), ae(Tn.prototype.terminate, "terminate"), "symbol" == typeof ne.toStringTag && Object.defineProperty(Tn.prototype, ne.toStringTag, { value: "TransformStreamDefaultController", configurable: !0 }), ({ AbortController: jn } = globalThis); class Nn { readableControllers = []; writers = []; _writableClosed = !1; get writableClosed() { return this._writableClosed } _closed = new e; get closed() { return this._closed.promise } options; constructor(e) { this.options = e ?? {} } wrapReadable(e) { return new Kn({ start: t => (this.readableControllers.push(t), e), cancel: async () => { await this.close() }, close: async () => { await this.dispose() } }) } createWritable(e) { const t = e.getWriter(); return this.writers.push(t), new tr({ write: async e => { await t.ready, await t.write(e) }, abort: async e => { await t.abort(e), await this.close() }, close: async () => { try { await t.close() } catch { } await this.close() } }) } async close() { if (!this._writableClosed) { this._writableClosed = !0, !1 !== await (this.options.close?.()) && await this.dispose(); for (const e of this.writers) try { await e.close() } catch { } } } async dispose() { this._writableClosed = !0, this._closed.resolve(); for (const e of this.readableControllers) try { e.close() } catch { } await (this.options.dispose?.()) } } class $n extends mn { constructor() { super({ transform(e, t) { t.enqueue(L(e)) } }) } } class Mn extends tr { _result = ""; get result() { return this._result } constructor() { super({ write: e => { this._result += e } }) } } class Dn { _readable; get readable() { return this._readable } _writable; get writable() { return this._writable } constructor(e) { let t; const r = new Jn(new Gn((e => t = e))); this._readable = new en({ async pull(t) { try { const n = await e.deserialize(r); t.enqueue(n) } catch (e) { if (e instanceof Xn) return void t.close(); throw e } } }), this._writable = new tr({ async write(e) { await t.enqueue(e) }, abort() { t.close() }, close() { t.close() } }) } } class Vn extends mn { constructor(e) { super({ transform(t, r) { r.enqueue(e.serialize(t)) } }) } } class Hn extends tr { writable; writer; constructor(e) { super({ start: async () => { await Promise.resolve(), this.writable = await async function (e) { return "start" in e ? await e.start() : "function" == typeof e ? await e() : e }(e), this.writer = this.writable.getWriter() }, write: async e => { await this.writer.ready, await this.writer.write(e) }, abort: async t => { await this.writer.abort(t), "close" in e && await (e.close?.()) }, close: async () => { await this.writer.close(), "close" in e && await (e.close?.()) } }) } } class Kn extends en { readable; reader; constructor(e) { super({ start: async t => { await Promise.resolve(), this.readable = await function (e, t) { return "start" in e ? e.start(t) : "function" == typeof e ? e(t) : e }(e, t), this.reader = this.readable.getReader() }, cancel: async t => { await this.reader.cancel(t), "cancel" in e && await (e.cancel?.(t)) }, pull: async t => { const r = await this.reader.read(); r.done ? (t.close(), "close" in e && await (e.close?.())) : t.enqueue(r.value) } }) } } class Yn extends mn { constructor(e) { super({ transform(t, r) { for (let n = 0; n < t.byteLength;) { const o = n + e; r.enqueue(t.subarray(n, o)), n = o } } }) } } function Qn(e, t) { const r = t.writable.getWriter(), n = t.readable.pipeTo(e); return new tr({ async write(e) { await r.ready, await r.write(e) }, async close() { await r.close(), await n } }) } class Gn extends en { constructor(t, r) { let n; const o = new jn; super({ start: r => { t({ abortSignal: o.signal, async enqueue(t) { if (o.signal.aborted) throw o.signal.reason ?? new Error("Aborted"); (r.desiredSize ?? 1) <= 0 && (n = new e, await n.promise), r.enqueue(t) }, close() { r.close() }, error(e) { r.error(e) } }) }, pull: () => { n?.resolve() }, cancel: async e => { o.abort(e), n?.reject(e) } }, r) } } class Xn extends Error { constructor() { super("Stream ended"), Object.setPrototypeOf(this, new.target.prototype) } } class Jn { buffered; bufferedOffset = 0; bufferedLength = 0; stream; reader; constructor(e) { this.stream = e, this.reader = e.getReader() } async readSource() { const { done: e, value: t } = await this.reader.read(); if (e) throw new Xn; return t } async readAsync(e, t) { let r, n; if (t) r = new Uint8Array(e), r.set(t), n = t.byteLength, e -= t.byteLength; else { const t = await this.readSource(); if (t.byteLength === e) return t; if (t.byteLength > e) return this.buffered = t, this.bufferedOffset = e, this.bufferedLength = t.byteLength - e, t.subarray(0, e); r = new Uint8Array(e), r.set(t), n = t.byteLength, e -= t.byteLength } for (; e > 0;) { const t = await this.readSource(); if (t.byteLength === e) return r.set(t, n), r; if (t.byteLength > e) return this.buffered = t, this.bufferedOffset = e, this.bufferedLength = t.byteLength - e, r.set(t.subarray(0, e), n), r; r.set(t, n), n += t.byteLength, e -= t.byteLength } return r } read(e) { if (this.buffered) { const t = this.buffered, r = this.bufferedOffset; return this.bufferedLength > e ? (this.bufferedOffset += e, this.bufferedLength -= e, t.subarray(r, r + e)) : (this.buffered = void 0, this.readAsync(e, t.subarray(r))) } return this.readAsync(e) } release() { return this.buffered ? new Gn((async e => { for (await e.enqueue(this.buffered); ;)try { const { done: t, value: r } = await this.reader.read(); if (t) { e.close(); break } await e.enqueue(r) } catch (t) { e.error(t); break } })) : (this.reader.releaseLock(), this.stream) } async close() { await this.reader.cancel() } } class Zn extends Jn { socket; get localId() { return this.socket.localId } get remoteId() { return this.socket.remoteId } get localCreated() { return this.socket.localCreated } get serviceString() { return this.socket.serviceString } get writable() { return this.socket.writable } constructor(e) { super(e.readable), this.socket = e } } var eo; !function (e) { e[e.Auth = 1213486401] = "Auth", e[e.Close = 1163086915] = "Close", e[e.Connect = 1314410051] = "Connect", e[e.OK = 1497451343] = "OK", e[e.Open = 1313165391] = "Open", e[e.Write = 1163154007] = "Write" }(eo = eo || (eo = {})); const to = new Y({ littleEndian: !0 }).uint32("command").uint32("arg0").uint32("arg1").uint32("payloadLength").uint32("checksum").int32("magic"); function ro(e) { return e instanceof Uint8Array ? e.reduce(((e, t) => e + t), 0) : (e.checksum = ro(e.payload), e) } new Y({ littleEndian: !0 }).fields(to).uint8Array("payload", { lengthField: "payloadLength" }); class no extends mn { constructor() { super({ transform: async (e, t) => { e.magic = 4294967295 ^ e.command, e.payloadLength = e.payload.byteLength, t.enqueue(to.serialize(e)), e.payload.byteLength && t.enqueue(e.payload) } }) } } var oo; !function (e) { e[e.Token = 1] = "Token", e[e.Signature = 2] = "Signature", e[e.PublicKey = 3] = "PublicKey" }(oo = oo || (oo = {})); const io = [async function* (e, t) { for await (const r of e.iterateKeys()) { const e = await t(); if (e.arg0 !== oo.Token) return; const n = g(r, e.payload); yield { command: eo.Auth, arg0: oo.Signature, arg1: 0, payload: new Uint8Array(n) } } }, async function* (e, t) { if ((await t()).arg0 !== oo.Token) return; let r; for await (const t of e.iterateKeys()) { r = t; break } r || (r = await e.generateKey()); const [n] = ee(524), o = new Uint8Array(n + 1); b(r, o), te(o.subarray(0, 524), o), yield { command: eo.Auth, arg0: oo.PublicKey, arg1: 0, payload: o } }]; class so { authenticators; credentialStore; pendingRequest = new e; iterator; constructor(e, t) { this.authenticators = e, this.credentialStore = t } getNextRequest = () => this.pendingRequest.promise; async*invokeAuthenticator() { for (const t of this.authenticators) for await (const r of t(this.credentialStore, this.getNextRequest)) this.pendingRequest = new e, yield r } async process(e) { this.iterator || (this.iterator = this.invokeAuthenticator()), this.pendingRequest.resolve(e); const t = await this.iterator.next(); if (t.done) throw new Error("No authenticator can handle the request"); return t.value } dispose() { this.iterator?.return?.() } } class ao { disposables = []; constructor() { this.dispose = this.dispose.bind(this) } addDisposable(e) { return this.disposables.push(e), e } dispose() { for (const e of this.disposables) e.dispose(); this.disposables = [] } } class lo extends ao { adb; constructor(e) { super(), this.adb = e } } const uo = new Y({ littleEndian: !0 }).uint32("version"), co = new Y({ littleEndian: !0 }).uint32("bpp").uint32("size").uint32("width").uint32("height").uint32("red_offset").uint32("red_length").uint32("blue_offset").uint32("blue_length").uint32("green_offset").uint32("green_length").uint32("alpha_offset").uint32("alpha_length").uint8Array("data", { lengthField: "size" }), ho = new Y({ littleEndian: !0 }).uint32("bpp").uint32("colorSpace").uint32("size").uint32("width").uint32("height").uint32("red_offset").uint32("red_length").uint32("blue_offset").uint32("blue_length").uint32("green_offset").uint32("green_length").uint32("alpha_offset").uint32("alpha_length").uint8Array("data", { lengthField: "size" }); class fo { static isSupported() { return !0 } static async pty(e, t) { return new fo(await e.createSocket(`shell:${t}`)) } static async raw(e, t) { return new fo(await e.createSocket(`exec:${t}`)) } socket; duplex; get stdin() { return this.socket.writable } _stdout; get stdout() { return this._stdout } _stderr; get stderr() { return this._stderr } _exit; get exit() { return this._exit } constructor(e) { this.socket = e, this.duplex = new Nn({ close: async () => { await this.socket.close() } }), this._stdout = this.duplex.wrapReadable(this.socket.readable), this._stderr = this.duplex.wrapReadable(new en), this._exit = this.duplex.closed.then((() => 0)) } resize() { } kill() { return this.duplex.close() } } var po, bo; !function (e) { e.ShellV2 = "shell_v2", e.Cmd = "cmd", e.StatV2 = "stat_v2", e.ListV2 = "ls_v2", e.FixedPushMkdir = "fixed_push_mkdir" }(po = po || (po = {})), function (e) { e[e.Stdin = 0] = "Stdin", e[e.Stdout = 1] = "Stdout", e[e.Stderr = 2] = "Stderr", e[e.Exit = 3] = "Exit", e[e.CloseStdin = 4] = "CloseStdin", e[e.WindowSizeChange = 5] = "WindowSizeChange" }(bo = bo || (bo = {})); const yo = new Y({ littleEndian: !0 }).uint8("id", void 0).uint32("length").uint8Array("data", { lengthField: "length" }); class go extends mn { constructor() { super({ transform(e, t) { t.enqueue({ id: bo.Stdin, data: e }) }, flush() { } }) } } class wo extends mn { constructor(e) { super({ transform(t, r) { t.id === e && r.enqueue(t.data) } }) } } class _o { _readable; _readableController; get readable() { return this._readable } _activeCount = 0; constructor() { this._readable = new Gn((e => { this._readableController = e })) } createWriteable() { return new tr({ start: () => { this._activeCount += 1 }, write: async e => { await this._readableController.enqueue(e) }, abort: async e => { this._activeCount -= 1, 0 === this._activeCount && this._readableController.close() }, close: async () => { this._activeCount -= 1, 0 === this._activeCount && this._readableController.close() } }) } } class mo { static isSupported(e) { return e.features.includes(po.ShellV2) } static async pty(e, t) { return new mo(await e.createSocket(`shell,v2,pty:${t}`)) } static async raw(e, t) { return new mo(await e.createSocket(`shell,v2,raw:${t}`)) } _socket; _socketWriter; _stdin; get stdin() { return this._stdin } _stdout; get stdout() { return this._stdout } _stderr; get stderr() { return this._stderr } _exit = new e; get exit() { return this._exit.promise } constructor(e) { this._socket = e; const [t, r] = e.readable.pipeThrough(new Dn(yo)).pipeThrough(new mn({ transform: (e, t) => { if (e.id === bo.Exit) return this._exit.resolve(new Uint8Array(e.data)[0]), void t.terminate(); t.enqueue(e) } })).tee(); this._stdout = t.pipeThrough(new wo(bo.Stdout)), this._stderr = r.pipeThrough(new wo(bo.Stderr)); const n = new _o; n.readable.pipeThrough(new Vn(yo)).pipeTo(e.writable), this._stdin = Qn(n.createWriteable(), new go), this._socketWriter = n.createWriteable().getWriter() } async resize(e, t) { await this._socketWriter.write({ id: bo.WindowSizeChange, data: C(`${e}x${t},0x0\0`) }) } kill() { return this._socket.close() } } function vo(e) { let t = ""; t += "'"; let r = 0; for (; ;) { const n = e.indexOf("'", r); if (-1 === n) { t += e.substring(r); break } t += e.substring(r, n), t += String.raw`'\''`, r = n + 1 } return t += "'", t } const So = { protocols: [mo, fo] }; class Eo { adb; constructor(e) { this.adb = e } async createProtocol(e, t, r) { const { protocols: n } = { ...So, ...r }; let o; for (const e of n) if (await e.isSupported(this.adb)) { o = e; break } if (!o) throw new Error("No specified protocol is supported by the device"); return Array.isArray(t) ? t = t.join(" ") : void 0 === t && (t = ""), await o[e](this.adb, t) } shell(e, t) { return this.createProtocol("pty", e, t) } spawn(e, t) { return this.createProtocol("raw", e, t) } async spawnAndWait(e, t) { const r = await this.spawn(e, t), n = new Mn, o = new Mn, [, , i] = await Promise.all([r.stdout.pipeThrough(new $n).pipeTo(n), r.stderr.pipeThrough(new $n).pipeTo(o), r.exit]); return { stdout: n.result, stderr: o.result, exitCode: i } } async spawnAndWaitLegacy(e) { const { stdout: t } = await this.spawnAndWait(e, { protocols: [fo] }); return t } } class Ro extends lo { reboot(e = "") { return this.adb.createSocketAndWait(`reboot:${e}`) } bootloader() { return this.reboot("bootloader") } fastboot() { return this.reboot("fastboot") } recovery() { return this.reboot("recovery") } sideload() { return this.reboot("sideload") } qualcommEdlMode() { return this.reboot("edl") } powerOff() { return this.adb.subprocess.spawnAndWaitLegacy(["reboot", "-p"]) } powerButton(e = !1) { return this.adb.subprocess.spawnAndWaitLegacy(["input", "keyevent", e ? "--longpress POWER" : "POWER"]) } samsungOdin() { return this.reboot("download") } } const To = (new Y).string("length", { length: 4 }).string("content", { lengthField: "length", lengthFieldRadix: 16 }), ko = (new Y).fields(To).postDeserialize((e => { throw new Error(e.content) })); class Ao extends ao { localAddressToHandler = new Map; deviceAddressToLocalAddress = new Map; adb; listening = !1; constructor(e) { super(), this.adb = e, this.addDisposable(this.adb.addIncomingSocketHandler(this.handleIncomingSocket)) } handleIncomingSocket = async e => { let t = e.serviceString; return t = t.replace(/\0/g, ""), !!await (this.localAddressToHandler.get(t)?.(e)) }; async createBufferedStream(e) { const t = await this.adb.createSocket(e); return new Zn(t) } async sendRequest(e) { const t = await this.createBufferedStream(e); return "OKAY" === L(await t.read(4)) || await ko.deserialize(t), t } async list() { const e = await this.createBufferedStream("reverse:list-forward"); return (await To.deserialize(e)).content.split("\n").map((e => { const [t, r, n] = e.split(" "); return { deviceSerial: t, localName: r, remoteName: n } })) } async add(e, t, r) { const n = await this.sendRequest(`reverse:forward:${e};${t}`); if (e.startsWith("tcp:")) { let t; try { t = Number.parseInt(L(await n.read(4)), 16) } catch (e) { if (!(e instanceof Xn)) throw e } if (void 0 !== t) { const r = L(await n.read(t)); e = `tcp:${Number.parseInt(r, 10)}` } } return this.localAddressToHandler.set(t, r), this.deviceAddressToLocalAddress.set(e, t), e } async remove(e) { await this.sendRequest(`reverse:killforward:${e}`), this.deviceAddressToLocalAddress.has(e) && (this.localAddressToHandler.delete(this.deviceAddressToLocalAddress.get(e)), this.deviceAddressToLocalAddress.delete(e)) } async removeAll() { await this.sendRequest("reverse:killforward-all"), this.deviceAddressToLocalAddress.clear(), this.localAddressToHandler.clear() } } var Io; !function (e) { e.List = "LIST", e.List2 = "LIS2", e.Send = "SEND", e.Lstat = "STAT", e.Stat = "STA2", e.Lstat2 = "LST2", e.Data = "DATA", e.Done = "DONE", e.Receive = "RECV" }(Io = Io || (Io = {})); const Oo = new Y({ littleEndian: !0 }).string("id", { length: 4 }).uint32("arg"), Po = new Y({ littleEndian: !0 }).fields(Oo).uint8Array("data", { lengthField: "arg" }); async function Bo(e, t, r) { let n; n = "number" == typeof r ? Oo.serialize({ id: t, arg: r }) : "string" == typeof r ? Po.serialize({ id: t, data: C(r) }) : Po.serialize({ id: t, data: r }), await e.write(n) } var Co; !function (e) { e.Entry = "DENT", e.Entry2 = "DNT2", e.Lstat = "STAT", e.Stat = "STA2", e.Lstat2 = "LST2", e.Done = "DONE", e.Data = "DATA", e.Ok = "OKAY", e.Fail = "FAIL" }(Co = Co || (Co = {})); class Lo { length; id = Co.Done; constructor(e) { this.length = e } async deserialize(e) { return await e.read(this.length), this } } const qo = new Y({ littleEndian: !0 }).uint32("messageLength").string("message", { lengthField: "messageLength" }).postDeserialize((e => { throw new Error(e.message) })); async function zo(e, t) { const r = L(await e.read(4)); if (r === Co.Fail && await qo.deserialize(e), t[r]) return t[r].deserialize(e); throw new Error(`Expected '${Object.keys(t).join(", ")}', but got '${r}'`) } var xo; !function (e) { e[e.Directory = 4] = "Directory", e[e.File = 8] = "File", e[e.Link = 10] = "Link" }(xo = xo || (xo = {})); const Wo = new Y({ littleEndian: !0 }).int32("mode").int32("size").int32("mtime").extra({ id: Co.Lstat, get type() { return this.mode >> 12 }, get permission() { return 4095 & this.mode } }).postDeserialize((e => { if (0 === e.mode && 0 === e.size && 0 === e.mtime) throw new Error("lstat failed") })); var Uo; !function (e) { e[e.SUCCESS = 0] = "SUCCESS", e[e.EACCES = 13] = "EACCES", e[e.EEXIST = 17] = "EEXIST", e[e.EFAULT = 14] = "EFAULT", e[e.EFBIG = 27] = "EFBIG", e[e.EINTR = 4] = "EINTR", e[e.EINVAL = 22] = "EINVAL", e[e.EIO = 5] = "EIO", e[e.EISDIR = 21] = "EISDIR", e[e.ELOOP = 40] = "ELOOP", e[e.EMFILE = 24] = "EMFILE", e[e.ENAMETOOLONG = 36] = "ENAMETOOLONG", e[e.ENFILE = 23] = "ENFILE", e[e.ENOENT = 2] = "ENOENT", e[e.ENOMEM = 12] = "ENOMEM", e[e.ENOSPC = 28] = "ENOSPC", e[e.ENOTDIR = 20] = "ENOTDIR", e[e.EOVERFLOW = 75] = "EOVERFLOW", e[e.EPERM = 1] = "EPERM", e[e.EROFS = 30] = "EROFS", e[e.ETXTBSY = 26] = "ETXTBSY" }(Uo = Uo || (Uo = {})); const Fo = new Y({ littleEndian: !0 }).uint32("error", void 0).uint64("dev").uint64("ino").uint32("mode").uint32("nlink").uint32("uid").uint32("gid").uint64("size").uint64("atime").uint64("mtime").uint64("ctime").extra({ id: Co.Stat, get type() { return this.mode >> 12 }, get permission() { return 4095 & this.mode } }).postDeserialize((e => { if (e.error) throw new Error(Uo[e.error]) })), jo = { [Co.Stat]: Fo }, No = { [Co.Lstat]: Wo }, $o = { [Co.Lstat2]: Fo }, Mo = new Y({ littleEndian: !0 }).fields(Wo).uint32("nameLength").string("name", { lengthField: "nameLength" }).extra({ id: Co.Entry }), Do = new Y({ littleEndian: !0 }).fields(Fo).uint32("nameLength").string("name", { lengthField: "nameLength" }).extra({ id: Co.Entry2 }), Vo = { [Co.Entry]: Mo, [Co.Done]: new Lo(Mo.size) }, Ho = { [Co.Entry2]: Do, [Co.Done]: new Lo(Do.size) }, Ko = new Y({ littleEndian: !0 }).uint32("dataLength").uint8Array("data", { lengthField: "dataLength" }).extra({ id: Co.Data }), Yo = { [Co.Data]: Ko, [Co.Done]: new Lo(Ko.size) }, Qo = new Y({ littleEndian: !0 }).uint32("unused"), Go = { [Co.Ok]: Qo }; function Xo(e) { const t = e.lastIndexOf("/"); if (-1 === t) throw new Error("Invalid path"); return 0 === t ? "/" : e.substring(0, t) } class Jo extends ao { adb; stream; writer; sendLock = this.addDisposable(new Q); get supportsStat() { return this.adb.features.includes(po.StatV2) } get supportsList2() { return this.adb.features.includes(po.ListV2) } get fixedPushMkdir() { return this.adb.features.includes(po.FixedPushMkdir) } get needPushMkdirWorkaround() { return this.adb.features.includes(po.ShellV2) && !this.fixedPushMkdir } constructor(e, t) { super(), this.adb = e, this.stream = new Zn(t), this.writer = t.writable.getWriter() } async lstat(e) { await this.sendLock.wait(); try { return async function (e, t, r, n) { let o, i; n ? (o = Io.Lstat2, i = $o) : (o = Io.Lstat, i = No), await Bo(t, o, r); const s = await zo(e, i); return s.id === Co.Lstat ? { mode: s.mode, size: BigInt(s.size), mtime: BigInt(s.mtime), get type() { return s.type }, get permission() { return s.permission } } : s }(this.stream, this.writer, e, this.supportsStat) } finally { this.sendLock.notify() } } async stat(e) { if (!this.supportsStat) throw new Error("Not supported"); await this.sendLock.wait(); try { return async function (e, t, r) { return await Bo(t, Io.Stat, r), await zo(e, jo) }(this.stream, this.writer, e) } finally { this.sendLock.notify() } } async isDirectory(e) { try { return await this.lstat(e + "/"), !0 } catch (e) { return !1 } } async*opendir(e) { await this.sendLock.wait(); try { yield* async function* (e, t, r, n) { let o, i; for (n ? (o = Io.List2, i = Ho) : (o = Io.List, i = Vo), await Bo(t, o, r); ;) { const t = await zo(e, i); switch (t.id) { case Co.Entry: yield { mode: t.mode, size: BigInt(t.size), mtime: BigInt(t.mtime), get type() { return t.type }, get permission() { return t.permission }, name: t.name }; break; case Co.Entry2: if (0 !== t.error) continue; yield t; break; case Co.Done: return; default: throw new Error("Unexpected response id") } } }(this.stream, this.writer, e, this.supportsList2) } finally { this.sendLock.notify() } } async readdir(e) { const t = []; for await (const r of this.opendir(e)) t.push(r); return t } read(e) { return new Kn({ start: async () => { return await this.sendLock.wait(), t = this.stream, r = this.writer, n = e, new en({ async start() { await Bo(r, Io.Receive, n) }, async pull(e) { const r = await zo(t, Yo); switch (r.id) { case Co.Data: e.enqueue(r.data); break; case Co.Done: e.close(); break; default: throw new Error("Unexpected response id") } }, cancel() { throw new Error("Sync commands don't support cancel.") } }, { highWaterMark: 16384, size: e => e.byteLength }); var t, r, n }, close: async () => { this.sendLock.notify() } }) } write(e, t, r) { return new Hn({ start: async () => (await this.sendLock.wait(), this.needPushMkdirWorkaround && await this.adb.subprocess.spawnAndWait(["mkdir", "-p", vo(Xo(e))]), function (e, t, r, n = xo.File << 12 | 438, o = Date.now() / 1e3 | 0, i = 65536) { return Qn(new tr({ async start() { const e = `${r},${n.toString()}`; await Bo(t, Io.Send, e) }, async write(e) { await Bo(t, Io.Data, e) }, async close() { await Bo(t, Io.Done, o), await zo(e, Go) } }), new Yn(i)) }(this.stream, this.writer, e, t, r)), close: async () => { this.sendLock.notify() } }) } async dispose() { super.dispose(), await this.stream.close(), await this.writer.close() } } class Zo extends lo { async setPort(e) { if (e <= 0) throw new Error(`Invalid port ${e}`); if (await this.adb.createSocketAndWait(`tcpip:${e}`) !== `restarting in TCP mode port: ${e}\n`) throw new Error("Invalid response") } async disable() { if ("restarting in USB mode\n" !== await this.adb.createSocketAndWait("usb:")) throw new Error("Invalid response") } } class ei { dispatcher; localId; remoteId; localCreated; serviceString; _duplex; _readable; _readableController; get readable() { return this._readable } _writePromise; writable; _closed = !1; get closed() { return this._closed } _socket; get socket() { return this._socket } constructor(t) { Object.assign(this, t), this._duplex = new Nn({ close: async () => (this._closed = !0, await this.dispatcher.sendPacket(eo.Close, this.localId, this.remoteId), !1), dispose: () => { this._writePromise?.reject(new Error("Socket closed")) } }), this._readable = this._duplex.wrapReadable(new Gn((e => { this._readableController = e }), { highWaterMark: t.highWaterMark ?? 16384, size: e => e.byteLength })), this.writable = Qn(this._duplex.createWritable(new tr({ write: async t => { this._writePromise = new e, await this.dispatcher.sendPacket(eo.Write, this.localId, this.remoteId, t), await this._writePromise.promise } })), new Yn(this.dispatcher.options.maxPayloadSize)), this._socket = new ti(this) } async enqueue(e) { this._readableController.abortSignal.aborted || await this._readableController.enqueue(e) } ack() { this._writePromise?.resolve() } async close() { await this._duplex.close() } dispose() { this._duplex.dispose() } } class ti { _controller; get localId() { return this._controller.localId } get remoteId() { return this._controller.remoteId } get localCreated() { return this._controller.localCreated } get serviceString() { return this._controller.serviceString } get readable() { return this._controller.readable } get writable() { return this._controller.writable } constructor(e) { this._controller = e } close() { return this._controller.close() } } class ri { initializers = new t(1); sockets = new Map; _writer; options; _closed = !1; _disconnected = new e; get disconnected() { return this._disconnected.promise } _incomingSocketHandlers = new Set; _abortController = new jn; constructor(e, t) { this.options = t, e.readable.pipeTo(new tr({ write: async e => { switch (e.command) { case eo.OK: this.handleOk(e); break; case eo.Close: await this.handleClose(e); break; case eo.Write: if (this.sockets.has(e.arg1)) { await this.sockets.get(e.arg1).enqueue(e.payload), await this.sendPacket(eo.OK, e.arg1, e.arg0); break } throw new Error(`Unknown local socket id: ${e.arg1}`); case eo.Open: await this.handleOpen(e); break; default: throw new Error(`Unknown command: ${e.command.toString(16)}`) } } }), { preventCancel: !0, signal: this._abortController.signal }).then((() => { this.dispose() }), (e => { this._closed || this._disconnected.reject(e), this.dispose() })), this._writer = e.writable.getWriter() } handleOk(e) { if (this.initializers.resolve(e.arg1, e.arg0)) return; const t = this.sockets.get(e.arg1); t ? t.ack() : this.sendPacket(eo.Close, e.arg1, e.arg0) } async handleClose(e) { if (0 === e.arg0 && this.initializers.reject(e.arg1, new Error("Socket open failed"))) return; const t = this.sockets.get(e.arg1); return t ? (t.closed || await this.sendPacket(eo.Close, e.arg1, e.arg0), t.dispose(), void this.sockets.delete(e.arg1)) : void 0 } addIncomingSocketHandler(e) { this._incomingSocketHandlers.add(e); const t = () => { this._incomingSocketHandlers.delete(e) }; return t.dispose = t, t } async handleOpen(e) { const [t] = this.initializers.add(); this.initializers.resolve(t, void 0); const r = e.arg0, n = L(e.payload), o = new ei({ dispatcher: this, localId: t, remoteId: r, localCreated: !1, serviceString: n }); for (const e of this._incomingSocketHandlers) if (await e(o.socket)) return this.sockets.set(t, o), void await this.sendPacket(eo.OK, t, r); await this.sendPacket(eo.Close, 0, r) } async createSocket(e) { this.options.appendNullToServiceString && (e += "\0"); const [t, r] = this.initializers.add(); await this.sendPacket(eo.Open, t, 0, e); const n = await r, o = new ei({ dispatcher: this, localId: t, remoteId: n, localCreated: !0, serviceString: e }); return this.sockets.set(t, o), o.socket } async sendPacket(e, t, r, n = W) { let o; if (void 0 === t ? o = e : ("string" == typeof n && (n = C(n)), o = { command: e, arg0: t, arg1: r, payload: n }), o.payload && o.payload.byteLength > this.options.maxPayloadSize) throw new Error("payload too large"); this.options.calculateChecksum ? ro(o) : o.checksum = 0, await this._writer.ready, await this._writer.write(o) } async close() { await Promise.all(Array.from(this.sockets.values(), (e => e.close()))), this._closed = !0, this._abortController.abort(), this._writer.releaseLock() } dispose() { for (const e of this.sockets.values()) e.dispose(); this._disconnected.resolve() } } var ni; !function (e) { e.Product = "ro.product.name", e.Model = "ro.product.model", e.Device = "ro.product.device", e.Features = "features" }(ni = ni || (ni = {})); class oi { static async authenticate(t, r, n = io) { let o = 16777217, i = 1048576; const s = new e, a = new so(n, r), l = new jn, u = t.readable.pipeTo(new tr({ async write(e) { switch (e.command) { case eo.Connect: o = Math.min(o, e.arg0), i = Math.min(i, e.arg1), s.resolve(L(e.payload)); break; case eo.Auth: const t = await a.process(e); await d(t) } } }), { preventCancel: !0, signal: l.signal }).catch((e => { s.reject(e) })), c = t.writable.getWriter(); async function d(e) { await c.write(ro(e)) } let h; try { const e = [po.ShellV2, po.Cmd, po.StatV2, po.ListV2, po.FixedPushMkdir, "apex", "abb", "fixed_push_symlink_timestamp", "abb_exec", "remount_shell", "track_app", "sendrecv_v2", "sendrecv_v2_brotli", "sendrecv_v2_lz4", "sendrecv_v2_zstd", "sendrecv_v2_dry_run_send"].join(","); await d({ command: eo.Connect, arg0: o, arg1: i, payload: C(`host::features=${e};`) }), h = await s.promise } finally { l.abort(), c.releaseLock(), await u } return new oi(t, o, i, h) } dispatcher; get disconnected() { return this.dispatcher.disconnected } _protocolVersion; get protocolVersion() { return this._protocolVersion } _product; get product() { return this._product } _model; get model() { return this._model } _device; get device() { return this._device } _features; get features() { return this._features } subprocess; power; reverse; tcpip; constructor(e, t, r, n) { let o, i; this.parseBanner(n), t >= 16777217 ? (o = !1, i = !1) : (o = !0, i = !0), this.dispatcher = new ri(e, { calculateChecksum: o, appendNullToServiceString: i, maxPayloadSize: r }), this._protocolVersion = t, this.subprocess = new Eo(this), this.power = new Ro(this), this.reverse = new Ao(this), this.tcpip = new Zo(this) } parseBanner(e) { this._features = []; const t = e.split("::"); if (t.length > 1) { const e = t[1]; for (const t of e.split(";")) { if (!t) continue; const e = t.split("="); if (2 !== e.length) continue; const [r, n] = e; switch (r) { case ni.Product: this._product = n; break; case ni.Model: this._model = n; break; case ni.Device: this._device = n; break; case ni.Features: this._features = n.split(",") } } } } addIncomingSocketHandler(e) { return this.dispatcher.addIncomingSocketHandler(e) } async createSocket(e) { return this.dispatcher.createSocket(e) } async createSocketAndWait(e) { const t = await this.createSocket(e), r = new Mn; return await t.readable.pipeThrough(new $n).pipeTo(r), r.result } async getProp(e) { return (await this.subprocess.spawnAndWaitLegacy(["getprop", e])).trim() } async rm(...e) { return await this.subprocess.spawnAndWaitLegacy(["rm", "-rf", ...e.map((e => vo(e)))]) } install() { return function (e) { const t = `/data/local/tmp/${Math.random().toString().substring(2)}.apk`; let r; return new Hn({ start: async () => (r = await e.sync(), r.write(t, void 0, void 0)), async close() { r.dispose(), await e.subprocess.spawnAndWaitLegacy(["pm", "install", vo(t)]), await e.rm(t) } }) }(this) } async sync() { const e = await this.createSocket("sync:"); return new Jo(this, e) } async framebuffer() { return async function (e) { const t = await e.createSocket("framebuffer:"), r = new Zn(t), { version: n } = await uo.deserialize(r); switch (n) { case 1: return co.deserialize(r); case 2: return ho.deserialize(r); default: throw new Error("Unknown FrameBuffer version") } }(this) } async close() { await this.dispatcher.close() } } const ii = { classCode: 255, subclassCode: 66, protocolCode: 1 }; class si { buffer; offset; constructor(e) { this.buffer = e, this.offset = 0 } read(e) { const t = this.buffer.subarray(this.offset, this.offset + e); return this.offset += e, t } } class ai { _readable; get readable() { return this._readable } _writable; get writable() { return this._writable } constructor(e, t, r) { const n = new Nn({ close: async () => { try { await e.close() } catch { } }, dispose: async () => { navigator.usb.removeEventListener("disconnect", o) } }); function o(t) { t.device === e && n.dispose() } navigator.usb.addEventListener("disconnect", o), this._readable = n.wrapReadable(new en({ async pull(r) { const n = await e.transferIn(t.endpointNumber, 24), o = new Uint8Array(n.data.buffer), i = new si(o), s = to.deserialize(i); if (0 !== s.payloadLength) { const r = await e.transferIn(t.endpointNumber, s.payloadLength); s.payload = new Uint8Array(r.data.buffer) } else s.payload = W; r.enqueue(s) } })), this._writable = Qn(n.createWritable(new tr({ write: async t => { await e.transferOut(r.endpointNumber, t) } }, { highWaterMark: 16384, size: e => e.byteLength })), new no) } } class li { static isSupported() { return !!globalThis.navigator?.usb } static async getDevices() { return (await window.navigator.usb.getDevices()).map((e => new li(e))) } static async requestDevice() { try { const e = await navigator.usb.requestDevice({ filters: [ii] }); return new li(e) } catch (e) { if (e instanceof DOMException && "NotFoundError" === e.name) return; throw e } } _device; get serial() { return this._device.serialNumber } get name() { return this._device.productName } constructor(e) { this._device = e } async connect() { this._device.opened || await this._device.open(); for (const e of this._device.configurations) for (const t of e.interfaces) for (const r of t.alternates) if (r.interfaceSubclass === ii.subclassCode && r.interfaceClass === ii.classCode && r.interfaceSubclass === ii.subclassCode) { let n, o; this._device.configuration?.configurationValue !== e.configurationValue && await this._device.selectConfiguration(e.configurationValue), t.claimed || await this._device.claimInterface(t.interfaceNumber), t.alternate.alternateSetting !== r.alternateSetting && await this._device.selectAlternateInterface(t.interfaceNumber, r.alternateSetting); for (const e of r.endpoints) switch (e.direction) { case "in": if (n = e, o) return new ai(this._device, n, o); break; case "out": if (o = e, n) return new ai(this._device, n, o) } } throw new Error("Unknown error") } } class ui { localStorageKey; constructor(e = "private-key") { this.localStorageKey = e } *iterateKeys() { const e = window.localStorage.getItem(this.localStorageKey); e && (yield function (e) { let t; t = "=" === e[e.length - 2] ? 2 : "=" === e[e.length - 1] ? 1 : 0; const r = new Uint8Array(e.length / 4 * 3 - t); let n = 0, o = 0; for (; n < e.length - (0 !== t ? 4 : 0);) { const t = G[e[n]]; n += 1; const i = G[e[n]]; n += 1; const s = G[e[n]]; n += 1; const a = G[e[n]]; n += 1, r[o] = t << 2 | (48 & i) >> 4, o += 1, r[o] = (15 & i) << 4 | (60 & s) >> 2, o += 1, r[o] = (3 & s) << 6 | a, o += 1 } if (1 === t) { const t = G[e[n]]; n += 1; const i = G[e[n]]; n += 1; const s = G[e[n]]; r[o] = t << 2 | (48 & i) >> 4, o += 1, r[o] = (15 & i) << 4 | (60 & s) >> 2 } else if (2 === t) { const t = G[e[n]]; n += 1; const i = G[e[n]]; r[o] = t << 2 | (48 & i) >> 4 } return r }(e)) } async generateKey() { const { privateKey: e } = await crypto.subtle.generateKey({ name: "RSASSA-PKCS1-v1_5", modulusLength: 2048, publicExponent: new Uint8Array([1, 0, 1]), hash: "SHA-1" }, !0, ["sign", "verify"]), t = new Uint8Array(await crypto.subtle.exportKey("pkcs8", e)); window.localStorage.setItem(this.localStorageKey, L(te(t))); const [r] = ee(524), n = new Uint8Array(r); return b(t, n), te(n.subarray(0, 524), n), window.localStorage.setItem(this.localStorageKey + ".pub", L(n)), t } } var ci = r(764), di = function (e, t, r, n) { return new (r || (r = Promise))((function (o, i) { function s(e) { try { l(n.next(e)) } catch (e) { i(e) } } function a(e) { try { l(n.throw(e)) } catch (e) { i(e) } } function l(e) { var t; e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r((function (e) { e(t) }))).then(s, a) } l((n = n.apply(e, t || [])).next()) })) }; window.Buf = ci; class hi { constructor() { this.callbacks = [], this.dec = new TextDecoder, this.enc = new TextEncoder } start() { return di(this, void 0, void 0, (function* () { const e = new ui, t = yield li.requestDevice(), r = yield t.connect(); return this.adb = yield oi.authenticate(r, e, void 0), this })) } tryAccSocket(e) { return di(this, void 0, void 0, (function* () { try { return yield this.adb.createSocket("tcp:1234") } catch (t) { return e > 0 ? (yield new Promise((e => setTimeout(e, 100))), this.tryAccSocket(e - 1)) : null } })) } connect(e) { return di(this, void 0, void 0, (function* () { let t = yield this.tryAccSocket(e); if (!t) return console.error(`Couldn't connect to socket after ${e} tries`), null; this.socket = t, this.writer = this.socket.writable.getWriter(); let r = ""; return this.socket.readable.pipeTo(new tr({ write: e => { let t = L(e); if (t.includes("")) { let e = t.split(""); this.handleData(r + e[0]), r = e[1] } else r += t } })), this })) } dispatchCommand(e, t) { return di(this, void 0, void 0, (function* () { let r = function () { var e = (new Date).getTime(), t = "undefined" != typeof performance && performance.now && 1e3 * performance.now() || 0; return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function (r) { var n = 16 * Math.random(); return e > 0 ? (n = (e + n) % 16 | 0, e = Math.floor(e / 16)) : (n = (t + n) % 16 | 0, t = Math.floor(t / 16)), ("x" === r ? n : 3 & n | 8).toString(16) })) }(); return this.write(JSON.stringify(Object.assign({ id: r, command: e }, t))), new Promise(((e, t) => { this.callbacks[r] = e })) })) } write(e) { return di(this, void 0, void 0, (function* () { this.writer && (yield this.writer.write(this.enc.encode(e + "\n"))) })) } handleData(e) { return di(this, void 0, void 0, (function* () { try { let t = JSON.parse(e), r = this.callbacks[t.id]; r ? (console.log("responding to command"), r(t)) : console.error("got a response for a command that does not exist. this should not happen.") } catch (t) { console.error("god dammit"); let r = e.split('}}{"id"'); yield this.handleData(r[0] + "}}"), yield this.handleData('{"id"' + r[1]) } })) } } window.onload = () => { document.querySelector("#start").addEventListener("click", (() => function (e, t, r, n) { return new (r || (r = Promise))((function (o, i) { function s(e) { try { l(n.next(e)) } catch (e) { i(e) } } function a(e) { try { l(n.throw(e)) } catch (e) { i(e) } } function l(e) { var t; e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r((function (e) { e(t) }))).then(s, a) } l((n = n.apply(e, t || [])).next()) })) }(void 0, void 0, void 0, (function* () { yield (new hi).start() })))) } })() })();
  </script>
</head>

<body>
  <button id="start">start</button>
</body>

</html>